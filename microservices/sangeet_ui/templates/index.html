<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Enhanced Music Player</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link href="/design/Poppins" rel="stylesheet">
  <link href="/design/material-icon-set" rel="stylesheet">
  <link rel="icon" type="image/gif" href="/data/download/icons/sangeet-home" sizes="any">
  <link href="/design/index" rel="stylesheet">
  <script src="/cdn/js/marked.min.js"></script>
  <style>
    /* CSS for Lyrics Status Tooltip */
    .lyrics-status-tooltip {
      position: absolute;
      /* Positioned relative to its offset parent, or fixed if no positioned parent */
      background-color: var(--card-color, #2a2a3e);
      /* Use your theme's card color */
      color: var(--text-primary, #f0f0f0);
      padding: 12px 18px;
      border-radius: 8px;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.35);
      z-index: 1070;
      /* Ensure it's above most elements but potentially below modals */
      font-size: 0.9em;
      line-height: 1.5;
      max-width: 280px;
      /* Prevent it from being too wide */
      border: 1px solid var(--surface-color, #3a3a4d);
      opacity: 0;
      transform: translateY(8px) scale(0.95);
      transition: opacity 0.25s cubic-bezier(0.25, 0.8, 0.25, 1), transform 0.25s cubic-bezier(0.25, 0.8, 0.25, 1);
      pointer-events: none;
      /* Initially not interactive */
      text-align: left;
      /* Ensure text is aligned left */
    }

    .lyrics-status-tooltip.visible {
      opacity: 1;
      transform: translateY(0) scale(1);
      pointer-events: auto;
      /* Interactive when visible */
    }

    .lyrics-status-tooltip::before {
      /* Optional: Arrow */
      content: '';
      position: absolute;
      bottom: 100%;
      /* Arrow points up */
      left: 20px;
      /* Adjust to align with indicator */
      margin-left: -8px;
      border-width: 8px;
      border-style: solid;
      border-color: transparent transparent var(--card-color, #2a2a3e) transparent;
    }

    .lyrics-status-tooltip h4 {
      margin-top: 0;
      margin-bottom: 8px;
      font-size: 1.05em;
      /* Slightly larger title */
      font-weight: 600;
      color: var(--accent-color, #1DB954);
      /* Use accent color for the title */
      border-bottom: 1px solid var(--surface-color, #3a3a4d);
      padding-bottom: 6px;
    }

    .lyrics-status-tooltip p {
      margin-bottom: 0;
      font-size: 0.95em;
    }
  </style>
  <style>
    .ripple {
      position: absolute;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.5);
      /* Semi-transparent white, adjust color as needed */
      transform: scale(0);
      animation: ripple-animation 0.6s linear;
      pointer-events: none;
      /* Ensures the ripple doesnâ€™t interfere with clicks */
    }

    @keyframes ripple-animation {
      to {
        transform: scale(4);
        /* Expands the circle */
        opacity: 0;
        /* Fades out smoothly */
      }
    }
  </style>
  <style id="version-info">
    @keyframes float {

      0%,
      100% {
        transform: translateY(0) rotate(0deg);
      }

      50% {
        transform: translateY(-20px) rotate(10deg);
      }
    }

    @keyframes twinkle {

      0%,
      100% {
        opacity: 0;
      }

      50% {
        opacity: 1;
      }
    }

    .music-note {
      position: absolute;
      font-size: 24px;
      pointer-events: none;
      animation: float 3s infinite, twinkle 3s infinite;
    }
  </style>
  <style>
    .glass-button {
      position: relative;
      padding: 16px 32px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 16px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 12px;
      transition: all 0.3s ease;
      overflow: hidden;
      text-decoration: none;
      /* Added to remove underline from anchor */
    }

    .glass-button:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
    }

    .glass-button:active {
      transform: translateY(0px);
    }

    .button-text {
      color: #2a2a2a;
      font-family: system-ui, -apple-system, sans-serif;
      font-weight: 500;
      font-size: 18px;
      z-index: 1;
    }

    .source-icon {
      width: 24px;
      height: 24px;
      animation: bounce 2s infinite;
    }

    .sparkle {
      position: absolute;
      width: 4px;
      height: 4px;
      border-radius: 50%;
      background: #fff;
      animation: sparkle 1.5s infinite;
    }

    @keyframes bounce {

      0%,
      100% {
        transform: translateY(0);
      }

      50% {
        transform: translateY(-4px);
      }
    }

    @keyframes sparkle {
      0% {
        transform: scale(0) rotate(0deg);
        opacity: 0;
      }

      50% {
        transform: scale(1) rotate(180deg);
        opacity: 1;
      }

      100% {
        transform: scale(0) rotate(360deg);
        opacity: 0;
      }
    }
  </style>
  <style>
    /* Playlist Header */
    .pl-header {
      display: flex;
      align-items: center;
      padding: 1rem;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* Back Button */
    .pl-back-btn {
      background: none;
      border: none;
      color: var(--primary-light);
      cursor: pointer;
      margin-right: 1rem;
    }

    .pl-back-btn:hover {
      color: var(--accent-color);
    }

    /* Enhanced Song Item */
    .pl-song-item {
      display: flex;
      align-items: center;
      padding: 0.5rem;
      background: var(--surface-color);
      border-radius: 4px;
      margin-bottom: 0.3rem;
    }

    .pl-song-item:hover {
      background: var(--card-color);
    }

    /* Song Thumbnail */
    .pl-song-thumb {
      width: 50px;
      height: 50px;
      object-fit: cover;
      border-radius: 4px;
      margin-right: 1rem;
    }

    /* Song Information */
    .pl-song-info {
      flex-grow: 1;
    }

    .pl-song-title {
      font-weight: 500;
      color: var(--text-primary);
    }

    .pl-song-artist {
      font-size: 0.9rem;
      color: var(--text-secondary);
    }

    /* Control Buttons */
    .pl-control-btn {
      background: none;
      border: none;
      color: var(--primary-light);
      cursor: pointer;
      padding: 0.5rem;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .pl-song-item:hover .pl-control-btn {
      opacity: 1;
    }
  </style>
  <style>
    /* ========== START ENHANCED LYRICS CSS (Version with Font/Instrument Guarantees & Performance) ========== */
    .lyrics-container-wrapper {
      width: 75%;
      /* Or your preferred width */
      max-width: 75%;
      /* Max width for the lyrics section */
      margin: 20px auto;
      /* Center it and add some margin */
    }

    #lyricsContainer {
      /* This is your main scrollable lyrics view */
      position: relative;
      scrollbar-width: thin;
      scrollbar-color: var(--primary-light) var(--surface-color);
      background-color: rgba(20, 20, 30, 0.75) !important;
      border: 1px solid rgba(255, 255, 255, 0.1);
      height: 400px;
      /* This can be overridden by inline styles */
      overflow-y: auto;
      text-align: center;
      border-radius: 12px;
      padding: 15px;
      -webkit-overflow-scrolling: touch;
      /* Smoother scrolling on iOS */
    }

    #lyricsContainer::-webkit-scrollbar {
      width: 8px;
    }

    #lyricsContainer::-webkit-scrollbar-track {
      background: var(--surface-color);
      border-radius: 10px;
    }

    #lyricsContainer::-webkit-scrollbar-thumb {
      background-color: var(--primary-light);
      border-radius: 10px;
      border: 2px solid var(--surface-color);
    }

    #lyrics-lines {
      position: relative;
      z-index: 2;
      /* Ensures lyrics are above any other content within #lyricsContainer */
      display: flex;
      flex-direction: column;
      align-items: center;
      transition: transform 0.3s ease-out;
      font-family: 'Poppins', system-ui, -apple-system, sans-serif;
      /* Explicitly use Poppins */
    }

    #lyrics-lines p {
      margin: 8px 0;
      padding: 10px 15px;
      border-radius: 8px;
      /* Slightly more rounded */
      cursor: pointer;
      transition: color 0.25s ease, background-color 0.25s ease, transform 0.25s ease, font-size 0.25s ease;
      font-size: 1.15em;
      /* Slightly increased base font size */
      color: var(--text-secondary);
      text-align: center;
      width: 90%;
      /* This makes it 90% of the #lyrics-lines container */
      line-height: 1.7;
      /* Increased for better readability with Poppins */
      letter-spacing: 0.01em;
      /* Subtle letter spacing */
    }

    #lyrics-lines p:hover {
      background-color: var(--card-color);
      color: var(--text-primary);
      transform: translateY(-1px);
      /* Subtle hover effect */
    }

    #lyrics-lines p.past {
      color: #999;
      /* Slightly darker grey for past */
      opacity: 0.75;
      font-size: 1.05em;
      /* Consistent smaller size for past */
    }

    #lyrics-lines p.active {
      color: var(--accent-color, #1DB954);
      font-weight: 600;
      /* Bolder active line */
      font-size: 1.4em;
      /* More prominent active line */
      transform: scale(1.03);
      background-color: rgba(var(--accent-color-rgb, 29, 185, 84), 0.12);
      /* Slightly more pronounced bg */
      text-shadow: 0 0 10px rgba(var(--accent-color-rgb, 29, 185, 84), 0.4);
      /* Glow effect */
      border-radius: 8px;
    }

    #lyrics-lines p.plain-lyrics {
      cursor: default;
      color: var(--text-primary);
      font-size: 1.15em;
      /* Match base synced lyric size */
    }

    #lyrics-lines p.plain-lyrics:hover {
      background-color: transparent;
      color: var(--text-primary);
      transform: none;
    }

    .lyrics-message {
      color: var(--text-secondary);
      font-style: italic;
      padding: 20px;
      width: 100%;
      text-align: center;
      font-family: 'Poppins', system-ui, -apple-system, sans-serif;
      font-size: 1em;
    }

    #lyrics-toggle-container {
      color: var(--text-secondary);
      text-align: right;
      margin-bottom: 10px;
      padding-right: 20px;
      /* This can be overridden by inline styles */
      font-family: 'Poppins', system-ui, -apple-system, sans-serif;
    }

    #lyrics-toggle-container label {
      margin-right: 5px;
      /* This can be overridden by inline styles */
      font-size: 0.9em;
      /* This can be overridden by inline styles */
    }



    .lyrics-gap-placeholder {
      width: 85%;
      height: 8px;
      background-color: rgba(255, 255, 255, 0.08);
      border-radius: 4px;
      margin: 15px auto;
      position: relative;
      overflow: hidden;
      display: none;
      cursor: default !important;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    }

    .lyrics-gap-placeholder.active {
      display: block;
    }

    .gap-fill-bar {
      height: 100%;
      width: 0%;
      background-color: var(--text-secondary);
      opacity: 0.5;
      border-radius: 4px;
      transition: width 0.2s linear;
    }

    .gap-text-indicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: rgba(255, 255, 255, 0.35);
      font-size: 1.0em;
      font-family: 'Poppins', system-ui, -apple-system, sans-serif;
      font-weight: 500;
      /* Adjusted weight */
      letter-spacing: 1.5px;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease-in-out;
      z-index: 1;
    }

    .lyrics-gap-placeholder.active .gap-text-indicator {
      opacity: 0.8;
    }

    .lyrics-gap-placeholder:hover {
      background-color: rgba(255, 255, 255, 0.08) !important;
      transform: none !important;
    }

    /* --- Background Music Notes (Revised for Gap Intensity & Performance) --- */
    /* The following section for #backgroundNotesContainer and related styles is now commented out */
    /*
#backgroundNotesContainer {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    pointer-events: none;
    z-index: 1; // Kept below lyrics-lines z-index
    display: none;
    opacity: 1;
}

#backgroundNotesContainer.active {
    display: block;
}

.background-gap-note {
    position: absolute;
    will-change: transform, opacity, animation-duration;
    text-shadow: 0px 0px 6px rgba(255, 255, 255, 0.1);
    opacity: 0.22; 
    transform: scale(1);
    animation-duration: var(--slow-duration);
    transition: opacity 0.75s cubic-bezier(0.4, 0, 0.2, 1),
                transform 0.75s cubic-bezier(0.4, 0, 0.2, 1);
}
*/

    /* Class for guaranteed prominent SVGs, if specific base styling needed */
    /*
.guaranteed-svg {
    // Potentially slightly higher base opacity or different z-index if needed
    // For now, mainly controlled by JS size and animation vars
}

#backgroundNotesContainer.gap-mode-active .background-gap-note {
    opacity: 0.60;
    transform: scale(1.1);
    animation-duration: var(--fast-duration);
}
*/

    /* Optimized Animations for Background Notes - Commented Out */
    /*
@keyframes backgroundNoteDriftAndFloat-Optimized {
  0% { transform: translate(0px, 0px) rotate(0deg); opacity: inherit; }
  25% { transform: translate(12px, -18px) rotate(-4deg); opacity: inherit; }
  50% { transform: translate(-10px, 15px) rotate(2deg); opacity: inherit; }
  75% { transform: translate(7px, -10px) rotate(5deg); opacity: inherit; }
  100% { transform: translate(0px, 0px) rotate(0deg); opacity: inherit; }
}

@keyframes backgroundNoteSwayAndRotate-Optimized {
  0% { transform: translate(0px, 2px) rotate(-2deg) scale(0.98); opacity: inherit; }
  33% { transform: translate(-18px, -12px) rotate(8deg) scale(1.03); opacity: inherit; }
  66% { transform: translate(12px, 10px) rotate(-6deg) scale(1); opacity: inherit; }
  100% { transform: translate(0px, 2px) rotate(-2deg) scale(0.98); opacity: inherit; }
}

@keyframes backgroundNotePulseAndGlide-Optimized {
  0%, 100% { transform: translate(2px, -3px) scale(1); opacity: inherit; }
  50% { transform: translate(-3px, 5px) scale(1.1); opacity: inherit; }
}

@keyframes backgroundNoteSpin-Optimized {
  from { transform: rotate(0deg) scale(0.95) translate(-8px, 8px); opacity: inherit; }
  to { transform: rotate(359deg) scale(1.03) translate(8px, -8px); opacity: inherit; }
}
*/
    /* Added CSS rules for lyrics gap loader color based on duration */
    .gap-fill-bar.fast {
      background-color: var(--accent-color, #1DB954);
      /* Green for fast gaps */
      opacity: 0.7;
      /* Adjusted opacity for better visibility */
    }

    .gap-fill-bar.medium {
      background-color: #FFEB3B;
      /* Yellow for medium gaps */
      opacity: 0.7;
      /* Adjusted opacity */
    }

    .gap-fill-bar.big {
      background-color: var(--text-secondary);
      /* Explicitly grey for big gaps */
      opacity: 0.5;
      /* Default opacity for big gaps */
    }

    /* End of Added CSS rules */
    /* ========== END ENHANCED LYRICS CSS ========== */
  </style>
  <style>
    /* Top Songs section */
    .artist-top-songs h4 {
      font-size: 1.1em;
      color: var(--text-primary);
      margin-bottom: 10px;
      padding-bottom: 5px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .sangeet-player-artist-top-songs-ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    .sangeet-player-artist-top-songs-ul .top-song-item {
      display: flex;
      align-items: center;
      padding: 10px 5px;
      /* Adjusted padding */
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
      cursor: pointer;
      transition: background-color 0.2s ease;
      border-radius: 4px;
      /* Slight rounding for items */
    }

    .sangeet-player-artist-top-songs-ul .top-song-item:hover {
      background-color: rgba(255, 255, 255, 0.05);
    }

    .sangeet-player-artist-top-songs-ul .top-song-item:last-child {
      border-bottom: none;
    }

    .sangeet-player-artist-top-songs-ul .top-song-thumbnail {
      width: 45px;
      /* Slightly larger */
      height: 45px;
      object-fit: cover;
      border-radius: 6px;
      /* Match rounding */
      margin-right: 15px;
      /* More spacing */
    }

    .sangeet-player-artist-top-songs-ul .song-number {
      margin-right: 15px;
      /* More spacing */
      color: var(--text-secondary);
      font-size: 0.9em;
      min-width: 20px;
      text-align: center;
    }

    .sangeet-player-artist-top-songs-ul .song-info {
      flex-grow: 1;
      overflow: hidden;
      /* Prevent long text from breaking layout */
    }

    .sangeet-player-artist-top-songs-ul .song-title {
      color: var(--text-primary);
      font-weight: 500;
      font-size: 0.95em;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      /* Ellipsis for long titles */
    }

    .sangeet-player-artist-top-songs-ul .song-artist-name {
      color: var(--text-secondary);
      font-size: 0.85em;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      /* Ellipsis for long artist names */
    }

    .sangeet-player-artist-top-songs-ul .song-details-right {
      text-align: right;
      font-size: 0.8em;
      color: var(--text-secondary);
      margin-left: 10px;
      min-width: 70px;
      /* Adjust as needed */
      display: flex;
      flex-direction: column;
      /* Stack plays and duration */
      align-items: flex-end;
    }

    .sangeet-player-artist-top-songs-ul .song-plays,
    .sangeet-player-artist-top-songs-ul .song-duration {
      white-space: nowrap;
    }


    .sangeet-player-artist-top-songs-ul .top-song-play-button {
      background: transparent;
      border: none;
      color: var(--text-secondary);
      /* Subtler default color */
      cursor: pointer;
      margin-left: 12px;
      /* More spacing */
      padding: 8px;
      /* Slightly larger click target */
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0.6;
      transition: opacity 0.2s ease, color 0.2s ease;
    }

    .sangeet-player-artist-top-songs-ul .top-song-item:hover .top-song-play-button {
      opacity: 1;
      color: var(--accent-color);
    }

    .sangeet-player-artist-top-songs-ul .top-song-play-button .material-icons {
      font-size: 22px;
      /* Adjust icon size */
    }


    /* Artist Links section */
    .artist-links {
      display: flex;
      gap: 12px;
      /* Slightly more gap */
      margin-top: 20px;
      /* More spacing from top songs */
      flex-wrap: wrap;
      padding-top: 15px;
      border-top: 1px solid rgba(255, 255, 255, 0.1);
    }

    .artist-links h4 {
      /* If you add a title for this section */
      width: 100%;
      font-size: 1.1em;
      color: var(--text-primary);
      margin-bottom: 10px;
    }

    .artist-link {
      display: inline-flex;
      align-items: center;
      padding: 8px 16px;
      /* More horizontal padding */
      background-color: rgba(255, 255, 255, 0.08);
      color: var(--text-secondary);
      /* Subtler text color for links */
      border-radius: 20px;
      text-decoration: none;
      font-size: 0.9em;
      transition: background-color 0.2s ease, color 0.2s ease;
      border: 1px solid rgba(255, 255, 255, 0.1);
      /* Subtle border */
    }

    .artist-link:hover {
      background-color: rgba(var(--accent-color-rgb, 29, 185, 84), 0.15);
      /* Use accent color on hover */
      color: var(--accent-color, #1DB954);
      border-color: rgba(var(--accent-color-rgb, 29, 185, 84), 0.3);
    }

    .artist-link .material-icons {
      margin-right: 8px;
      font-size: 1.2em;
      /* Slightly larger icon */
    }

    .artist-overview-container p {
      /* For description and messages */
      line-height: 1.6;
      color: var(--text-secondary);
    }
  </style>
  <style>
    /* ====== START: Added CSS for Lyrics Panel Header Row and Color Legend ====== */

    .lyrics-panel-header-row {
      display: flex;
      justify-content: space-between;
      /* Distributes space between left, center, and right items */
      align-items: center;
      padding: 0 15px;
      /* Adjust padding as needed */
      margin-bottom: 10px;
      /* Spacing below the header row */
      width: 100%;
      box-sizing: border-box;
      min-height: 28px;
      /* Ensure row has some height */
      position: relative;
      /* For potential future absolute positioning within it */
    }

    /* Spacer for the left side to help center the legend.
   It will take up an equal amount of flexible space as the right-side toggle container. */
    .lyrics-panel-header-row>.lyrics-header-spacer-left {
      flex: 1;
      /* If you want it to be completely invisible and just take space:
     visibility: hidden;
     Or leave it empty.
  */
    }

    /* CSS for the Color Legend and its hide/show animation */
    .lyrics-panel-color-legend {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 12px;
      /* Or 15px, consistent with your preference */
      padding: 5px 0;

      /* Added for smooth animation */
      opacity: 1;
      transform: translateY(0) scale(1);
      visibility: visible;
      transition: opacity 0.3s ease-out,
        transform 0.3s ease-out,
        visibility 0s linear 0s;
      /* Apply/remove visibility immediately or after transition */
    }

    .lyrics-panel-color-legend.hidden-smooth {
      opacity: 0;
      transform: translateY(-10px) scale(0.95);
      /* Example: moves slightly up and shrinks */
      pointer-events: none;
      /* Prevent interactions when hidden */
      visibility: hidden;
      transition: opacity 0.3s ease-out,
        transform 0.3s ease-out,
        visibility 0s linear 0.3s;
      /* Delay making it truly hidden until after animation */
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 5px;
      /* Space between a color line and its text label */
      cursor: default;
      /* Or 'help' if you want to indicate the title attribute */
    }

    .legend-line {
      display: inline-block;
      width: 22px;
      /* Length of the color line */
      height: 7px;
      /* Thickness of the color line */
      border-radius: 3.5px;
      /* Makes it a fully rounded pill shape (height / 2) */
      background-color: #777;
      /* Default fallback color */
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
      /* Subtle shadow for depth */
      transition: transform 0.2s cubic-bezier(0.25, 0.8, 0.25, 1);
      /* Smooth transition for hover */
    }

    .legend-line:hover {
      transform: scale(1.15);
      /* Slightly enlarge on hover for interactivity */
    }

    /* Specific colors for legend lines - Creative Meanings */
    .legend-line.vocals {
      background-color: #04d400;
      /* Bright Cyan/Teal - "Flowing Vocals / Melody Line" */
    }

    .legend-line.instruments {
      background-color: #FFEB3B;
      /* Warm Orange - "Instrumental Richness / Harmonies" */
    }

    .legend-line.rhythm {
      background-color: #e4d8dc;
      /* Vibrant Pink - "Rhythmic Drive / Beat Pulse" */
    }

    /* You can add more colors and meanings here if needed:
.legend-line.bass { background-color: #3F51B5; } // Indigo for Bassline
.legend-line.effects { background-color: #795548; } // Brown for Sound Effects/Atmosphere
*/

    .legend-text {
      font-size: 0.7em;
      /* Small, clear text for the legend */
      color: var(--text-secondary, #bbb);
      /* Use theme's secondary text color */
      font-weight: 500;
      line-height: 1;
    }

    /* Adjustments to the existing #lyrics-toggle-container when part of the new header row */
    #lyrics-toggle-container {
      /* It's now a flex item on the right */
      flex: 1;
      /* Allows it to take up space, balancing the left spacer */
      display: flex;
      justify-content: flex-end;
      /* Align its own content (status, label, checkbox) to the right */
      align-items: center;
      gap: 8px;
      /* Space between the status indicator, label, and checkbox */

      /* Original styles that might need to be removed or are overridden by parent/defaults: */
      /* text-align: right; */
      /* No longer needed as flex handles alignment */
      /* padding-right: 20px; */
      /* Parent .lyrics-panel-header-row handles padding */
      /* margin-bottom: 10px; */
      /* Parent .lyrics-panel-header-row handles margin */
      /* color: var(--text-secondary); */
      /* Inherited or can be kept */
      /* font-family: 'Poppins', system-ui, -apple-system, sans-serif; */
      /* Inherited or can be kept */
    }

    /* Ensure the dynamically added status indicator fits well */
    #lyrics-type-indicator {
      /* margin-left: 0; /* Reset if it had a specific margin before */
      /* Other styles for idxLyricsStatusIndicatorEl are applied by JS */
    }

    /* ====== END: Added CSS for Lyrics Panel Header Row and Color Legend ====== */
  </style>
  <style>
    /* ====== START: CSS for Modern Lyrics Toggle Switch ====== */

    /* 1. Visually hide the original checkbox but keep it functional and accessible */
    #lyrics-toggle {
      position: absolute;
      opacity: 0;
      width: 0;
      height: 0;
      z-index: -1;
      /* Behind the custom UI */
    }

    /* 2. Style the label to become the switch */
    /* Add this class to your <label for="lyrics-toggle"> */
    .lyrics-toggle-switch-label {
      cursor: pointer;
      display: inline-flex;
      /* Allows alignment of internal text/icons */
      align-items: center;
      width: 100px;
      /* Adjust width to fit "Plain" / "Synced" text */
      height: 30px;
      /* Height of the switch */
      background-color: #767577;
      /* Default color for OFF state (Plain) */
      border-radius: 15px;
      /* Fully rounded track (height / 2) */
      position: relative;
      transition: background-color 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      user-select: none;
      vertical-align: middle;
      /* Aligns well with other items in the row */
      padding: 0 4px;
      /* Inner padding for knob and text */
      box-sizing: border-box;
      overflow: hidden;
      /* Clip content during transition */
      color: white;
      /* Text color */
      font-family: 'Poppins', system-ui, -apple-system, sans-serif;
      /* Match surrounding text */
    }

    /* 3. The sliding knob */
    .lyrics-toggle-switch-label::before {
      content: '';
      position: absolute;
      top: 3px;
      /* (Track Height - Knob Height) / 2 */
      left: 3px;
      /* Initial position for OFF state */
      width: 24px;
      /* Knob diameter */
      height: 24px;
      background-color: white;
      border-radius: 50%;
      /* Circular knob */
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
      transition: transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      z-index: 1;
      /* Knob is above the text track */
    }

    /* 4. Text and Icons for "Plain" (OFF) and "Synced" (ON) states */
    .lyrics-toggle-switch-label .toggle-text-label {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      font-size: 0.75em;
      font-weight: 500;
      display: flex;
      align-items: center;
      transition: opacity 0.2s ease-in-out, transform 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
      z-index: 0;
      /* Text is behind the knob */
    }

    .lyrics-toggle-switch-label .toggle-text-label .material-icons {
      font-size: 14px;
      /* Icon size */
      margin-right: 4px;
    }

    /* "Plain" state text/icon (default visible) */
    .lyrics-toggle-switch-label .toggle-text-plain {
      left: 32px;
      /* Positioned to the right of the knob in OFF state */
      opacity: 1;
    }

    /* "Synced" state text/icon (initially hidden) */
    .lyrics-toggle-switch-label .toggle-text-synced {
      right: 32px;
      /* Would be to the left of the knob in ON state */
      opacity: 0;
      /* Will be translated into view */
      transform: translateY(-50%) translateX(20px);
      /* Initially off-screen to slide in */
    }


    /* 5. Styles when the toggle is ON (checkbox is checked) */
    /* THIS REQUIRES JAVASCRIPT to add the 'is-checked' class to the label */
    .lyrics-toggle-switch-label.is-checked {
      background-color: var(--accent-color, #1DB954);
      /* Color for ON state (Synced) */
    }

    .lyrics-toggle-switch-label.is-checked::before {
      /* Knob moves to the right */
      transform: translateX(calc(100px - 24px - 6px));
      /* TrackWidth - KnobWidth - (2 * KnobLeftOffset) */
      /* 100 - 24 - 6 = 70px */
    }

    .lyrics-toggle-switch-label.is-checked .toggle-text-plain {
      opacity: 0;
      transform: translateY(-50%) translateX(-20px);
      /* Slide out */
    }

    .lyrics-toggle-switch-label.is-checked .toggle-text-synced {
      opacity: 1;
      left: 8px;
      /* Positioned to the left of the knob in ON state */
      right: auto;
      transform: translateY(-50%) translateX(0);
      /* Slide in */
    }


    /* 6. Accessibility: Focus style on the label when the hidden checkbox has focus */
    /* This relies on JS to add a 'js-focus-visible' class to the label when the checkbox receives focus,
   OR if you can reorder HTML to have <input> before <label>, you can use:
   #lyrics-toggle:focus-visible + .lyrics-toggle-switch-label { ... }
*/
    .lyrics-toggle-switch-label.js-focus-visible {
      outline: 2px solid var(--accent-color-rgb, rgba(29, 185, 84, 0.4));
      outline-offset: 2px;
      box-shadow: 0 0 5px var(--accent-color-rgb, rgba(29, 185, 84, 0.7));
    }

    /* Helper class to visually hide the original label text if you keep it inside the label */
    .visually-hidden {
      position: absolute;
      width: 1px;
      height: 1px;
      padding: 0;
      margin: -1px;
      overflow: hidden;
      clip: rect(0, 0, 0, 0);
      white-space: nowrap;
      border: 0;
    }

    /* ====== END: CSS for Modern Lyrics Toggle Switch ====== */
  </style>
  <style>
    .song-card.processing {
      opacity: 0.7;
      cursor: not-allowed;
    }

    .song-status-indicator {
      position: absolute;
      top: 10px;
      right: 10px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 3px 8px;
      border-radius: 5px;
      font-size: 0.8em;
      z-index: 2;
    }

    .song-card.playing .song-status-indicator,
    .song-card:not(.processing) .song-status-indicator {
      display: none;
    }
  </style>
  <style>
    /* Settings Modal Styles */
.settings-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.7);
  display: none; /* Initially hidden */
  align-items: center;
  justify-content: center;
  z-index: 1050; /* Make sure it's above other content */
}

.settings-modal-content {
  background: var(--card-color);
  padding: 2rem;
  border-radius: 12px;
  width: 90%;
  max-width: 500px;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
  color: var(--text-primary);
}

.settings-modal-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid var(--surface-color);
  padding-bottom: 1rem;
  margin-bottom: 1rem;
}

.settings-modal-header h2 {
  margin: 0;
}

.settings-modal-body {
    margin-bottom: 1.5rem;
}

.setting-item {
  margin-bottom: 1.5rem;
}

.setting-label {
  display: flex;
  align-items: center;
  margin-bottom: 0.5rem;
}

.setting-label h3 {
  margin: 0;
  font-size: 1.1rem;
}

.quality-options {
  display: flex;
  flex-direction: column;
  gap: 0.1rem;
}

.quality-option {
  padding: 0.75rem 1rem;
  border: 1px solid var(--surface-color);
  border-radius: 8px;
  cursor: pointer;
  transition: background-color 0.2s, border-color 0.2s;
}

.quality-option:hover {
  background-color: var(--surface-color);
}

.quality-option.selected {
  background-color: var(--accent-color);
  color: white;
  border-color: var(--accent-color);
}

.question-mark {
  margin-left: 0.5rem;
  cursor: pointer;
  position: relative;
  display: inline-block;
}

.question-mark .tooltip {
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  background-color: #333;
  color: #fff;
  padding: 0.5rem 1rem;
  border-radius: 6px;
  white-space: pre-wrap; /* Allows wrapping */
  visibility: hidden;
  opacity: 0;
  transition: opacity 0.2s, visibility 0.2s;
  width: max-content;
  max-width: 300px;
  text-align: left;
}

.question-mark:hover .tooltip {
  visibility: visible;
  opacity: 1;
}

.settings-modal-footer {
    border-top: 1px solid var(--surface-color);
    padding-top: 1rem;
    text-align: right;
}
  </style>
  <style>
    /* ========== START: Isolated "idx-" Portal Menu CSS ========== */
        :root {
            --idx-portal-overlay-bg: rgba(10, 11, 20, 0.75);
            --idx-portal-text-primary: #f0f5ff;
            --idx-portal-accent-primary: #00c6ff;
            --idx-portal-accent-secondary: #0072ff;
            --idx-portal-glow-color: rgba(0, 198, 255, 0.7);
        }

        /* body {
            font-family: 'Poppins', sans-serif;
            background-color: #111;
            margin: 0;
            padding: 0;
        } */

        .idx-portal-handle {
            position: fixed;
            top: 50%;
            left: 0;
            transform: translateY(-50%);
            width: 24px;
            height: 100px;
            background: linear-gradient(135deg, var(--idx-portal-accent-primary), var(--idx-portal-accent-secondary));
            border-radius: 0 12px 12px 0;
            z-index: 1002;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 2px 0 15px rgba(0, 0, 0, 0.4);
            transition: all 0.4s ease;
        }

        .idx-portal-handle:hover {
            left: 3px;
            box-shadow: 0 0 25px var(--idx-portal-glow-color);
        }

        .idx-portal-handle>.material-icons {
            color: white;
            font-size: 24px;
        }

        .idx-portal-menu.active~.idx-portal-handle {
            left: -50px;
        }

        .idx-portal-menu {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 90vmin;
            height: 90vmin;
            max-width: 550px;
            max-height: 550px;
            transform: translate(-50%, -50%) scale(0);
            z-index: 1001;
            opacity: 0;
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            pointer-events: none;
        }

        .idx-portal-menu.active {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
            pointer-events: all;
        }

        .idx-menu-active-label {
            position: absolute;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            font-family: 'Poppins', system-ui, sans-serif;
            font-size: clamp(1.25rem, 5vmin, 2rem);
            font-weight: 700;
            color: var(--idx-portal-text-primary);
            text-shadow: 0 0 10px var(--idx-portal-glow-color);
            transition: all 0.3s;
            user-select: none;
            pointer-events: none;
        }

        .idx-central-hub {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20%;
            height: 20%;
            background: linear-gradient(135deg, #2a2f3a, #1c1f26);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 2px solid rgba(255, 255, 255, 0.1);
            transform: translate(-50%, -50%) scale(1);
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.5);
        }

        .idx-portal-menu.active .idx-central-hub {
            animation: idx-pulse-hub-subtle 4s ease-in-out infinite;
        }

        @keyframes idx-pulse-hub-subtle {

            0%,
            100% {
                transform: translate(-50%, -50%) scale(1);
            }

            50% {
                transform: translate(-50%, -50%) scale(1.03);
            }
        }

        .idx-hub-icon {
            font-size: clamp(1.5rem, 5vmin, 2.5rem);
            color: var(--idx-portal-text-primary);
            opacity: 0.8;
            pointer-events: none;
        }

        .idx-menu-container {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 100%;
            transform: translate(-50%, -50%);
        }

        .idx-menu-item {
            position: absolute;
            width: 15%;
            height: 15%;
            background: #2a2f3a;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: grab;
            transition: all 0.3s ease;
            border: 2px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5);
            color: white;
        }

        .idx-menu-item:active {
            cursor: grabbing;
        }

        .idx-menu-item.active,
        .idx-menu-item:hover {
            transform: scale(1.1) !important;
            background: #2a2f3a;
            border-color: var(--idx-portal-accent-primary);
            box-shadow: 0 0 8px 2px var(--idx-portal-glow-color),
                inset 0 0 8px 2px var(--idx-portal-glow-color);
        }

        .idx-menu-icon {
            font-size: clamp(1rem, 4vmin, 1.75rem);
            transition: transform 0.4s ease;
            pointer-events: none;
        }

        .idx-cosmic-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--idx-portal-overlay-bg);
            backdrop-filter: blur(10px) saturate(120%);
            opacity: 0;
            visibility: hidden;
            transition: all 0.5s ease;
            z-index: 1000;
        }

        .idx-cosmic-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .idx-tooltip {
            display: none;
        }

        /* ========== END: Isolated "idx-" Portal Menu CSS ========== */
  </style>
</head>
  <div class="idx-portal-handle" id="idx-portalMenuTrigger">
        <span class="material-icons">drag_handle</span>
    </div>

    <div class="idx-cosmic-overlay" id="idx-portalMenuOverlay"></div>

    <div class="idx-portal-menu" id="idx-portalMenu">
        <div class="idx-menu-active-label" id="idx-menuActiveLabel"></div>
        <div class="idx-central-hub">
            <span class="material-icons idx-hub-icon">track_changes</span>
        </div>
        <div class="idx-menu-container" id="idx-menuContainer">
            <button class="idx-menu-item" data-action="history">
                <span class="material-icons idx-menu-icon">history</span>
                <div class="idx-tooltip">History</div>
            </button>
            <button class="idx-menu-item" data-action="insights">
                <span class="material-icons idx-menu-icon">insights</span>
                <div class="idx-tooltip">Insights</div>
            </button>
            <button class="idx-menu-item" data-action="playlists">
                <span class="material-icons idx-menu-icon">playlist_play</span>
                <div class="idx-tooltip">Playlists</div>
            </button>
            <button class="idx-menu-item" data-action="settings">
                <span class="material-icons idx-menu-icon">settings</span>
                <div class="idx-tooltip">Settings</div>
            </button>
            <button class="idx-menu-item" data-action="whats-new">
                <span class="material-icons idx-menu-icon">info</span>
                <div class="idx-tooltip">About</div>
            </button>
            <button class="idx-menu-item" data-action="report-issue">
                <span class="material-icons idx-menu-icon">report_problem</span>
                <div class="idx-tooltip">Issues</div>
            </button>
            <button class="idx-menu-item" id="idx-sangeet-menu-get-extension"
                onclick="window.open('/get-extension', '_blank')">
                <span class="material-icons idx-menu-icon">extension</span>
                <div class="idx-tooltip">Get Extension</div>
            </button>
            <button class="idx-menu-item" id="idx-sangeet-menu-logout" onclick="window.location.href='/logout'">
                <span class="material-icons idx-menu-icon">logout</span>
                <div class="idx-tooltip">Logout</div>
            </button>
        </div>
    </div>

    <div id="idx-original-menu-actions" style="display: none;">
        <button data-action="history"></button>
        <button data-action="insights"></button>
        <button data-action="playlists"></button>
        <button data-action="settings"></button>
        <button data-action="whats-new"></button>
        <button data-action="report-issue"></button>
    </div>

  <div class="container">
    <!-- Enhanced Search Section -->
    <div class="search-container">
      <input type="text" class="search-input" id="searchInput" placeholder="Search for songs or tap mic to speak..." />
      <div class="search-icons">
        <span class="material-icons search-icon" id="micIcon">mic</span>
        <span class="material-icons search-icon broom-icon" id="broomIcon">cleaning_services</span>
      </div>
    </div>

    <!-- Insights Modal Section -->
    <div class="insights-modal" id="insightsModal">
      <div class="insights-content">
        <div class="insights-header">
          <h2>Listening Insights</h2>
          <button class="close-button" id="closeInsights">
            <span class="material-icons">close</span>
          </button>
        </div>

        <div class="insights-body">
          <!-- Overview Insight Section -->
          <section class="insight-section">
            <h3>Overview</h3>
            <div class="stats-grid">
              <div class="stat-card">
                <span class="material-icons">schedule</span>
                <div class="stat-value" id="totalListeningTime">0h</div>
                <div class="stat-label">Total Time</div>
              </div>
              <div class="stat-card">
                <span class="material-icons">music_note</span>
                <div class="stat-value" id="totalSongs">0</div>
                <div class="stat-label">Songs Played</div>
              </div>
              <div class="stat-card">
                <span class="material-icons">group</span>
                <div class="stat-value" id="uniqueArtists">0</div>
                <div class="stat-label">Artists</div>
              </div>
              <div class="stat-card">
                <span class="material-icons">trending_up</span>
                <div class="stat-value" id="averageDaily">0</div>
                <div class="stat-label">Daily Average</div>
              </div>
            </div>
          </section>

          <!-- Top Artists Insight Section -->
          <section class="insight-section">
            <h3>Top Artists</h3>
            <div class="top-artists-list" id="topArtistsList"></div>
          </section>

          <!-- Listening Patterns Insight Section -->
          <section class="insight-section">
            <h3>Listening Patterns</h3>
            <div class="patterns-container">
              <div class="pattern-chart">
                <h4>Daily Activity</h4>
                <div id="dailyPatternChart"></div>
              </div>
              <div class="pattern-chart">
                <h4>Hourly Activity</h4>
                <div id="hourlyPatternChart"></div>
              </div>
            </div>
          </section>

          <!-- Recent Activity Insight Section -->
          <section class="insight-section">
            <h3>Recent Activity</h3>
            <div class="recent-activity-list" id="recentActivityList"></div>
          </section>


        </div>
      </div>
    </div>

    <!-- Results Grid Section -->
    <div class="results-container" id="resultsContainer"></div>

    <!-- Infinite Loader Section -->
    <div id="infiniteLoader" style="text-align:center; color:var(--text-secondary); display:none;">
      Loading more...
    </div>
  </div>

  <!-- Mini Player Section -->
  <div class="mini-player hidden" id="miniPlayer">
    <div class="mini-player-info">
      <img src="" alt="Cover" class="mini-player-thumb" id="miniPlayerThumb" />
      <div class="mini-player-text">
        <div class="mini-player-title" id="miniPlayerTitle">Title</div>
        <div class="mini-player-artist" id="miniPlayerArtist">Artist</div>
      </div>
    </div>

    <div class="player-controls">
      <button class="control-button" id="prevButton">
        <span class="material-icons">skip_previous</span>
      </button>
      <button class="control-button play-pause" id="playButton">
        <span class="material-icons">play_circle</span>
      </button>
      <button class="control-button" id="nextButton">
        <span class="material-icons">skip_next</span>
      </button>
    </div>

    <div class="progress-container" id="progressContainer">
      <div class="progress-bar">
        <div class="progress" id="progressBar"></div>
        <div class="progress-skeleton" id="progressSkeleton"></div>
        <div class="progress-hover" id="progressHover"></div>
      </div>
      <div class="time-indicator">
        <span id="currentTime">0:00</span>
        <span id="totalTime">0:00</span>
      </div>
    </div>

    <div class="volume-control">
      <button class="control-button" id="volumeButton">
        <span class="material-icons">volume_up</span>
      </button>
      <input type="range" class="volume-slider" min="0" max="100" value="100" id="volumeSlider" />
    </div>

    <button class="control-button expand" id="expandButton">
      <span class="material-icons">expand_less</span>
    </button>
  </div>

  <!-- Enhanced Full Player Section -->
  <div class="full-player" id="fullPlayer">
    <div class="full-player-header">
      <button class="control-button" id="minimizeButton" style="right:2rem; top:1.3rem; position: absolute; ">
        <span class="material-icons">expand_more</span>
      </button>
    </div>

    <div class="full-player-content">
      <div class="full-player-main">
        <div class="full-player-art">
          <img src="" alt="Cover" id="fullPlayerArt">
        </div>

        <div class="full-player-info">
          <div class="marquee">
            <div class="text" id="fullPlayerTitle">Choose a song to play</div>
          </div>
          <div class="full-player-artist" id="fullPlayerArtist">-</div>

          <div class="player-controls">
            <button class="control-button" id="fullPrevButton">
              <span class="material-icons">skip_previous</span>
            </button>
            <button class="control-button play-pause" id="fullPlayButton">
              <span class="material-icons">play_arrow</span>
            </button>
            <button class="control-button" id="fullNextButton">
              <span class="material-icons">skip_next</span>
            </button>
            <!-- Add to Playlist Button -->
            <button class="control-button" id="addToPlaylistButton" title="Add to Playlist">
              <span class="material-icons">playlist_add</span>
            </button>
          </div>

          <div class="progress-container" id="fullProgressContainer">
            <div class="progress-bar">
              <div class="progress" id="fullProgressBar"></div>
              <div class="progress-hover" id="fullProgressHover"></div>
            </div>
            <div class="time-indicator">
              <span id="fullCurrentTime">0:00</span>
              <span id="fullTotalTime">0:00</span>
            </div>
          </div>
        </div>
      </div>


      <div class="lyrics-container-wrapper" id="mainLyricsPanel">
        <div id="lyrics-toggle-container">
          <div class="modern-lyrics-toggle">
            <input type="checkbox" id="lyrics-toggle" class="lyrics-toggle-checkbox" checked>
            <label for="lyrics-toggle" class="lyrics-toggle-label lyrics-toggle-switch-label">
              <span class="visually-hidden">Toggle Lyrics Sync and Seek</span>


              <span class="toggle-text-label toggle-text-synced">Synced</span>
              <span class="toggle-text-label toggle-text-plain">Plain</span>
            </label>
          </div>
        </div>

        <div class="lyrics-panel-header-row">
          <div class="lyrics-header-spacer-left">
          </div>

          <div class="lyrics-panel-color-legend">
            <div class="legend-item" title="Main Vocals / Melody Line">
              <span class="legend-line vocals"></span>
              <span class="legend-text">low Gap</span>
            </div>
            <div class="legend-item" title="Instrumental Richness / Harmonies">
              <span class="legend-line instruments"></span>
              <span class="legend-text">Medium Gap</span>
            </div>
            <div class="legend-item" title="Rhythmic Drive / Beat Pulse">
              <span class="legend-line rhythm"></span>
              <span class="legend-text">High Music</span>
            </div>
          </div>


        </div>
        <div class="lyrics-container" id="lyricsContainer"
          style="height: 350px; /* Adjust as needed */ overflow-y: auto; text-align: center; border-radius: 12px; background: rgba(20, 20, 30, 0.5); padding:15px;">
          <div id="lyrics-lines"
            style="display: flex; flex-direction: column; align-items: center; transition: transform 0.3s ease-out;">
            <p class="lyrics-message" style="color: var(--text-secondary); font-style: italic;">Lyrics will load when a
              song plays...</p>
          </div>
        </div>
      </div>
      <div class="artist-info-container">
        <img src="" alt="Artist" class="artist-image" id="artistImage">
        <div class="artist-details">
          <div class="artist-name" id="artistName">Artist Name</div>
          <div class="artist-year" id="artistYear">Year: -</div>
          <div class="artist-genre" id="artistGenre">Genre: -</div>
        </div>
      </div>

      <div class="artist-overview-container">
        <div class="artist-overview-header">
          <h3>Artist Overview</h3>
        </div>
        <div class="artist-description">
          <h4>About</h4>
          <p id="artistDescription">Loading artist details...</p>
        </div>
        <div class="artist-stats">
          <div class="stat-card">
            <span class="material-icons">group</span>
            <div class="stat-value" id="artistSubscribers">-</div>
            <div class="stat-label">Subscribers</div>
          </div>
          <div class="stat-card">
            <span class="material-icons">visibility</span>
            <div class="stat-value" id="artistViews">-</div>
            <div class="stat-label">Total Views</div>
          </div>
          <div class="stat-card">
            <span class="material-icons">headphones</span>
            <div class="stat-value" id="artistMonthlyListeners">-</div>
            <div class="stat-label">Monthly Listeners</div>
          </div>
        </div>
        <div class="artist-top-songs">
          <h4>Popular Songs</h4>
          <div class="top-songs-list" id="topSongsList">
          </div>
        </div>
        <div class="artist-links" id="artistLinks">
        </div>
      </div>


    </div>

    <!-- Integration Container Section -->
    <div class="integration-container" id="integrationContainer" style="display: none;">
      <div class="integration-header">
        <h3 class="text-lg font-bold mb-4">Integrate this Song</h3>
        <button class="close-button" id="closeIntegration">
          <span class="material-icons">close</span>
        </button>
      </div>

      <div class="integration-options">
        <div class="integration-sizes">
          <label class="text-sm text-gray-300 mb-2">Choose Size:</label>
          <div class="size-buttons">
            <button class="size-btn active" data-size="small">Small</button>
            <button class="size-btn" data-size="normal">Normal</button>
            <button class="size-btn" data-size="large">Large</button>
          </div>
        </div>

        <div class="integration-themes">
          <label class="text-sm text-gray-300 mb-2">Choose Theme:</label>
          <div class="theme-buttons">
            <button class="theme-btn active" data-theme="default">
              <span class="theme-color default"></span>
              Default
            </button>
            <button class="theme-btn" data-theme="purple">
              <span class="theme-color purple"></span>
              Purple
            </button>
            <button class="theme-btn" data-theme="blue">
              <span class="theme-color blue"></span>
              Blue
            </button>
            <button class="theme-btn" data-theme="dark">
              <span class="theme-color dark"></span>
              Dark
            </button>
          </div>
        </div>

        <div class="integration-preview">
          <label class="text-sm text-gray-300 mb-2">Preview:</label>
          <div class="preview-container" id="previewContainer">
            <iframe id="previewFrame" frameborder="0" allowtransparency="true" allow="encrypted-media"></iframe>
          </div>
        </div>

        <div class="integration-code">
          <label class="text-sm text-gray-300 mb-2">Embed Code:</label>
          <div class="code-container">
            <pre id="embedCode" class="code-block"></pre>
            <button class="copy-btn" id="copyCode">
              <span class="material-icons">content_copy</span>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>


  <!-- History Modal Section -->
  <div id="historyModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Listening History</h2>
        <button class="close-button" id="closeHistory">
          <span class="material-icons">close</span>
        </button>
      </div>
      <div class="modal-body">
        <div id="historyList" class="history-list"></div>
      </div>
    </div>
  </div>
  <div id="playlistModal" class="modal">
    <div class="modal-content">
      <span class="close-button">&times;</span>
      <h2 id="modalHeader">Playlists</h2>
      <div id="createPlaylistSection" style="display: none;">
        <!-- <input type="text" id="newPlaylistName" placeholder="Enter playlist name"> -->
        <input type="text" id="newPlaylistName" placeholder="Enter playlist name"
          style="padding: 8px; border: 1px solid #ccc; border-radius: 4px; font-size: 16px; outline: none; width: 200px;">
        <button id="submitPlaylistBtn">Create</button>
        <button id="cancelPlaylistBtn">Cancel</button>
      </div>
      <button id="createPlaylistBtn">Create New Playlist</button>
      <div id="playlistList">
        <!-- Playlist items or songs will be inserted here dynamically -->
      </div>
    </div>
  </div>

  <div class="http-warning-overlay" id="httpWarningOverlay">
    <div class="http-warning-widget">
      <div class="http-warning-title">Features Warning</div>
      <div class="http-warning-message">
        You're accessing this page via HTTP. Some features, like share and musch more, are unavailable without HTTPS.
      </div>
      <div class="http-warning-recommendation" id="httpWarningRecommendation">
        Please use HTTPS for the best experience. Access via a secure domain or contact your admin for secure access.
      </div>
      <button class="http-warning-close" id="httpWarningClose">
        <span class="material-icons">close</span>
      </button>
    </div>
  </div>
  <div id="whatsNewModal" class="modal whats-new-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 id="whatsNewModalTitle">About Me</h2>
        <button class="close-button" id="closeWhatsNewModal" aria-label="Close What's New">
          <span class="material-icons">close</span>
        </button>
      </div>
      <div class="modal-body">
        <div id="whatsNewContent" class="markdown-body">
          <div class="skeleton-loading" style="height: 200px; width: 100%;"></div>
        </div>
      </div>
    </div>
  </div>
  <div id="settingsModal" class="settings-modal">
    <div class="settings-modal-content">
      <div class="settings-modal-header">
        <h2>Settings</h2>
        <button id="closeSettingsModal" class="close-button">
          <span class="material-icons">close</span>
        </button>
      </div>
      <div class="settings-modal-body">
        <div class="setting-item">
          <div class="setting-label">
            <h3>Stream Quality</h3>
            <div class="question-mark">
              <span class="material-icons">help_outline</span>
              <div class="tooltip">
                <p><strong>Low (OPUS):</strong> Higher bitrate along with less space....</p>
                <p><strong>Normal (OGG - Vorbis):</strong> ~192 kbps. Balanced quality and data usage.</p>
                <p><strong>Lossless (FLAC):</strong> Highest quality, uses the most data.</p>
              </div>
            </div>
          </div>
          <div class="quality-options">
            <div class="quality-option" data-quality="low">Low (OPUS)</div>
            <div class="quality-option selected" data-quality="normal">Normal (OGG - Vorbis)</div>
            <div class="quality-option" data-quality="lossless">Lossless (FLAC)</div>
          </div>
        </div>
      </div>
      <div class="settings-modal-footer">
        <button id="saveSettings" class="menu-item">Save Settings</button>
      </div>
    </div>
  </div>


  <!-- Hidden Audio Element -->
  <audio id="audioElement" preload="auto"></audio>


  <script>


    /**
     * Global state management
     * Handles all dynamic data for the player including:
     * - Current playback state
     * - Queue management
     * - Search state
     * - Volume settings
     */
    const state = {
      currentSongId: null,        // Currently playing/selected song ID
      recommendationsLoading: false, // Flag for recommendation loading state
      maxQueueSize: 50,          // Maximum songs in queue
      isPlaying: false,          // Current playback state
      queue: [],                 // Song queue array
      queueIndex: -1,            // Current position in queue
      volume: localStorage.getItem("player-volume") || 100, // Playback volume (0-100)
      searchQuery: "",           // Current search query
      searchPage: 0,             // Current page for infinite scroll
      searchLimit: 20,           // Items per page
      searchHasMore: true,       // Flag for more results available
      loadingMore: false,        // Flag for loading state
      displayedItems: new Set(), // Track displayed songs to prevent duplicates
      processingTasks: new Set()
    };


    /**
     * DOM Elements
     * Centralized access to all DOM elements used by the player
     * Grouped by functionality for better organization
     */
    const E = {
      // Search Related Elements
      searchInput: document.getElementById("searchInput"),
      broomIcon: document.getElementById("broomIcon"),
      micIcon: document.getElementById("micIcon"),
      resultsContainer: document.getElementById("resultsContainer"),
      infiniteLoader: document.getElementById("infiniteLoader"),
      whatsNewModal: document.getElementById("whatsNewModal"),
      closeWhatsNewModal: document.getElementById("closeWhatsNewModal"),
      whatsNewContent: document.getElementById("whatsNewContent"),

      // Mini Player Elements
      miniPlayer: document.getElementById("miniPlayer"),
      miniPlayerThumb: document.getElementById("miniPlayerThumb"),
      miniPlayerTitle: document.getElementById("miniPlayerTitle"),
      miniPlayerArtist: document.getElementById("miniPlayerArtist"),
      playButton: document.getElementById("playButton"),
      prevButton: document.getElementById("prevButton"),
      nextButton: document.getElementById("nextButton"),

      // Progress Elements
      progressBar: document.getElementById("progressBar"),
      progressSkeleton: document.getElementById("progressSkeleton"),
      progressContainer: document.getElementById("progressContainer"),
      progressHover: document.getElementById("progressHover"),
      currentTime: document.getElementById("currentTime"),
      totalTime: document.getElementById("totalTime"),

      // Volume Elements
      volumeSlider: document.getElementById("volumeSlider"),
      volumeButton: document.getElementById("volumeButton"),

      // Full Player Elements
      expandButton: document.getElementById("expandButton"),
      minimizeButton: document.getElementById("minimizeButton"),
      fullPlayer: document.getElementById("fullPlayer"),
      fullPlayerArt: document.getElementById("fullPlayerArt"),
      fullPlayerTitle: document.getElementById("fullPlayerTitle"),
      fullPlayerArtist: document.getElementById("fullPlayerArtist"),

      // Content Elements
      lyricsContainer: document.getElementById("lyricsContainer"),
      artistImage: document.getElementById("artistImage"),
      artistName: document.getElementById("artistName"),
      artistYear: document.getElementById("artistYear"),
      artistGenre: document.getElementById("artistGenre"),

      // Full Player Controls
      fullPlayButton: document.getElementById("fullPlayButton"),
      fullPrevButton: document.getElementById("fullPrevButton"),
      fullNextButton: document.getElementById("fullNextButton"),
      fullProgressBar: document.getElementById("fullProgressBar"),
      fullProgressContainer: document.getElementById("fullProgressContainer"),
      fullProgressHover: document.getElementById("fullProgressHover"),
      fullCurrentTime: document.getElementById("fullCurrentTime"),
      fullTotalTime: document.getElementById("fullTotalTime"),

      // Audio Element
      audio: document.getElementById("audioElement")
    };

    /**
     * Core Utility Functions
     * Basic helper functions used throughout the application
     */

    /**
     * Format time in seconds to MM:SS format
     * @param {number} sec - Time in seconds
     * @returns {string} Formatted time string
     */


    /**
     * Debounce function for search input
     * @param {Function} fn - Function to debounce
     * @param {number} delay - Delay in milliseconds
     */
    function debounce(fn, delay) {
      let t;
      return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn(...args), delay);
      };
    }

    /**
     * Show toast notification
     * @param {string} message - Message to display
     */
    function showToast(message, type = 'info') {
      // const toast = document.createElement('div');
      // toast.className = 'toast-notification';
      // toast.textContent = message;
      // document.body.appendChild(toast);
      // setTimeout(() => toast.remove(), 3000);
      showNotification(type, 'Sangeet Premium Plus', message, 4000);
    }

    /**
     * Initial styles setup
     * Add required styles for toast notifications and controls
     */
    const additionalStyles = document.createElement('style');
    additionalStyles.textContent = `
  .toast-notification {
    position: fixed;
    bottom: 100px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 12px 24px;
    border-radius: 24px;
    font-size: 14px;
    z-index: 1000;
    animation: toastIn 0.3s ease, toastOut 0.3s ease 2.7s forwards;
  }

  @keyframes toastIn {
    from { opacity: 0; transform: translate(-50%, 20px); }
    to { opacity: 1; transform: translate(-50%, 0); }
  }

  @keyframes toastOut {
    from { opacity: 1; transform: translate(-50%, 0); }
    to { opacity: 0; transform: translate(-50%, 20px); }
  }

  .additional-controls {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    border-left: 1px solid rgba(255,255,255,0.1);
    padding-left: 1rem;
    margin-left: 0.5rem;
  }

  .full-player .additional-controls {
    border: none;
    padding-left: 0;
    margin-left: 1rem;
  }

  @media (max-width: 768px) {
    .additional-controls {
      border: none;
      padding-left: 0;
    }
  }
`;
    document.head.appendChild(additionalStyles);
    /**
     * Enhanced Music Player - Complete JavaScript Implementation
     * =======================================================
     *
     * PART 2: Speech Recognition & Player Controls
     */

    /**
     * Speech Recognition Setup
     * Handles voice search functionality
     */
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    const recognition = SpeechRecognition ? new SpeechRecognition() : null;

    function setupSpeechRecognition() {
      if (!recognition) {
        E.micIcon.style.display = 'none';
        return;
      }

      recognition.continuous = false;
      recognition.interimResults = false;
      recognition.lang = 'en-US';

      let isListening = false;
      let wasPlaying = false; // Tracks if audio was playing before STT

      function startListening() {
        try {
          isListening = true;
          E.micIcon.textContent = 'mic';
          E.micIcon.classList.add('listening');
          E.micIcon.style.color = 'var(--primary-light)';
          E.searchInput.placeholder = 'Listening...';

          // Pause audio if itâ€™s playing
          if (E.audio && !E.audio.paused) {
            wasPlaying = true;
            E.audio.pause();
          } else {
            wasPlaying = false;
          }

          recognition.start();
        } catch (err) {
          console.error('Speech recognition start error:', err);
          stopListening();
        }
      }

      function stopListening() {
        isListening = false;
        E.micIcon.classList.remove('listening');
        E.micIcon.style.color = '';
        E.micIcon.textContent = 'mic';
        E.searchInput.placeholder = 'Search for songs or tap mic to speak...';

        // Resume audio if it was playing
        if (wasPlaying && E.audio.paused) {
          E.audio.play().catch(error => {
            console.error('Error resuming playback:', error);
            showToast('Failed to resume playback', 'error');
          });
        }
        wasPlaying = false; // Reset the flag

        try {
          recognition.stop();
        } catch (err) {
          console.error('Speech recognition stop error:', err);
        }
      }

      // Speech Recognition Event Handlers
      recognition.onstart = () => {
        isListening = true;
        E.micIcon.textContent = 'mic';
        E.micIcon.classList.add('listening');
      };

      recognition.onend = () => {
        stopListening();
      };

      recognition.onresult = (event) => {
        const transcript = event.results[0][0].transcript;
        E.searchInput.value = transcript;
        E.searchInput.dispatchEvent(new Event('input'));

        E.micIcon.textContent = 'done';
        setTimeout(() => {
          E.micIcon.textContent = 'mic';
        }, 1000);
      };

      recognition.onerror = (event) => {
        console.error('Speech recognition error:', event.error);
        E.micIcon.textContent = 'mic_off';
        let errorMessage;
        switch (event.error) {
          case 'network':
            errorMessage = 'Network error: Please check your internet connection.';
            break;
          case 'no-speech':
            errorMessage = 'No speech detected. Please try again.';
            break;
          case 'not-allowed':
            errorMessage = 'Permission denied. Ensure the page is served over HTTPS or localhost.';
            break;
          default:
            errorMessage = 'An error occurred during speech recognition.';
        }
        showToast(errorMessage, 'error');
        setTimeout(() => {
          stopListening();
        }, 1000);
      };

      // Mic Icon Event Listeners
      E.micIcon.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        isListening ? stopListening() : startListening();
      });

      E.micIcon.addEventListener('touchend', (e) => {
        e.preventDefault();
        e.stopPropagation();
        isListening ? stopListening() : startListening();
      });
    }

    /**
     * Player Controls Setup
     * Handles all player control buttons and functionality
     */

    // Define control button templates
    const additionalControls = `
<div class="additional-controls">
  <button class="control-button" id="downloadButton" title="Download song">
    <span class="material-icons">download</span>
  </button>
  <button class="control-button" id="shareButton" title="Share song">
    <span class="material-icons">share</span>
  </button>
</div>
`;

    const fullPlayerControls = `
<div class="additional-controls">
  <button class="control-button" id="fullDownloadButton" title="Download song">
    <span class="material-icons">download</span>
  </button>
  <button class="control-button" id="fullShareButton" title="Share song">
    <span class="material-icons">share</span>
  </button>
</div>
`;

    /**
     * Initialize Player Controls
     * Sets up all control buttons and their event handlers
     */
    function initializePlayerControls() {
      // Add controls to players
      document.querySelector('.volume-control').insertAdjacentHTML('afterend', additionalControls);
      document.querySelector('.full-player .player-controls').insertAdjacentHTML('beforeend', fullPlayerControls);



      const controls = {
        share: {
          mini: document.getElementById('shareButton'),
          full: document.getElementById('fullShareButton')
        },
        download: {
          mini: document.getElementById('downloadButton'),
          full: document.getElementById('fullDownloadButton')
        }
      };

      /**
       * Handle song sharing
       * Provides native share or fallback to clipboard copy
       */
      async function handleShare() {
        if (!state.currentSongId) return;

        const shareUrl = `${window.location.origin}/share/open/${state.currentSongId}`;
        const songTitle = `${E.miniPlayerTitle.textContent} - ${E.miniPlayerArtist.textContent}`;

        try {
          if (navigator.share) {
            await navigator.share({
              title: songTitle,
              text: 'Check out this song!',
              url: shareUrl
            });
          } else {
            await navigator.clipboard.writeText(shareUrl);
            Object.values(controls.share).forEach(btn => {
              if (btn) {
                const icon = btn.querySelector('.material-icons');
                icon.textContent = 'check';
                setTimeout(() => icon.textContent = 'share', 2000);
              }
            });
            showToast('Share link copied to clipboard!');
          }
        } catch (err) {
          console.error('Share failed:', err);
        }
      }

      /**
       * Handle song download
       * Downloads current song and shows feedback
       */
      async function handleDownload() {
        if (!state.currentSongId) return;

        try {
          // Update button states
          Object.values(controls.download).forEach(btn => {
            if (btn) {
              const icon = btn.querySelector('.material-icons');
              icon.textContent = 'cloud_download';
            }
          });

          // Trigger download
          const link = document.createElement('a');
          link.href = `/api/download/${state.currentSongId}`;
          link.style.display = 'none';
          document.body.appendChild(link);
          link.click();
          document.body.removeChild(link);

          // Show success
          Object.values(controls.download).forEach(btn => {
            if (btn) {
              const icon = btn.querySelector('.material-icons');
              icon.textContent = 'cloud_done';
              setTimeout(() => icon.textContent = 'download', 2000);
            }
          });

        } catch (error) {
          console.error('Download error:', error);
          // Show error
          Object.values(controls.download).forEach(btn => {
            if (btn) {
              const icon = btn.querySelector('.material-icons');
              icon.textContent = 'cloud_off';
              setTimeout(() => icon.textContent = 'download', 2000);
            }
          });
          showToast('Download failed. Please try again.');
        }
      }

      // Attach event listeners to all controls
      Object.values(controls.share).forEach(btn => {
        btn?.addEventListener('click', handleShare);
      });

      Object.values(controls.download).forEach(btn => {
        btn?.addEventListener('click', handleDownload);
      });
    }

    /**
     * Volume Control Functions
     * Handles volume slider and mute functionality
     */
    function handleVolumeChange(e) {
      state.volume = e.target.value;
      localStorage.setItem("player-volume", state.volume);
      E.audio.volume = state.volume / 100;
      updateVolumeIcon(state.volume);
    }

    function toggleMute() {
      if (E.audio.volume > 0) {
        E.volumeSlider.dataset.lastVol = state.volume;
        E.volumeSlider.value = 0;
        state.volume = 0;
      } else {
        const lastVol = E.volumeSlider.dataset.lastVol || 100;
        E.volumeSlider.value = lastVol;
        state.volume = lastVol;
      }
      E.volumeSlider.dispatchEvent(new Event("input"));
    }

    function updateVolumeIcon(volume) {
      const icon = E.volumeButton.querySelector(".material-icons");
      if (volume == 0) icon.textContent = "volume_off";
      else if (volume < 50) icon.textContent = "volume_down";
      else icon.textContent = "volume_up";
    }
    /**
     * Enhanced Music Player - Complete JavaScript Implementation
     * =======================================================
     *
     * PART 3: Media Playback & Progress Tracking
     */

    /**
     * Progress Bar Setup
     * Handles progress bar interaction and display
     */
    function setupProgressBar(container, progressHover, callback) {
      if (!container || !progressHover) return;

      let isDragging = false;

      container.addEventListener("mousemove", (e) => {
        const rect = container.getBoundingClientRect();
        const percent = ((e.clientX - rect.left) / rect.width) * 100;
        progressHover.style.width = `${percent}%`;

        if (isDragging && E.audio.duration) {
          E.audio.currentTime = E.audio.duration * (percent / 100);
        }
      });

      container.addEventListener("mouseleave", () => {
        progressHover.style.width = "0%";
      });

      container.addEventListener("mousedown", () => {
        isDragging = true;
      });

      document.addEventListener("mouseup", () => {
        isDragging = false;
      });

      container.addEventListener("click", (e) => {
        const rect = container.getBoundingClientRect();
        const percent = (e.clientX - rect.left) / rect.width;
        if (E.audio.duration) {
          E.audio.currentTime = E.audio.duration * percent;
          if (callback) callback(percent);
        }
      });

      // Touch support
      container.addEventListener("touchstart", (e) => {
        e.preventDefault();
        isDragging = true;
      });

      container.addEventListener("touchmove", (e) => {
        if (!isDragging) return;
        const touch = e.touches[0];
        const rect = container.getBoundingClientRect();
        const percent = ((touch.clientX - rect.left) / rect.width) * 100;
        progressHover.style.width = `${percent}%`;

        if (E.audio.duration) {
          E.audio.currentTime = E.audio.duration * (percent / 100);
        }
      });

      container.addEventListener("touchend", () => {
        isDragging = false;
      });
    }


    /**
     * Toggle play/pause state
     */
    // Add these functions to your JavaScript where you handle audio playback

    // Track loading state
    let isAudioLoading = false;
    let playAfterLoad = false;

    // Enhanced audio initialization
    function initializeAudio() {
      const audioElement = document.getElementById('audioElement');

      // Loading states
      audioElement.addEventListener('loadstart', () => {
        isAudioLoading = true;
        console.log('Audio loading started');
      });

      audioElement.addEventListener('canplay', () => {
        isAudioLoading = false;
        console.log('Audio can play');
        if (playAfterLoad) {
          playAfterLoad = false;
          playAudioSafely();
        }
      });

      // Error handling
      audioElement.addEventListener('error', (e) => {
        isAudioLoading = false;
        playAfterLoad = false;
        console.error('Audio error:', e);
      });

      // Abort handling
      audioElement.addEventListener('abort', () => {
        isAudioLoading = false;
        playAfterLoad = false;
        console.log('Audio loading aborted');
      });
    }


    // Add this safe play function
    async function playAudioSafely() {
      try {
        if (isAudioLoading) {
          playAfterLoad = true;
          return;
        }

        if (E.audio.readyState >= 2) { // HAVE_CURRENT_DATA or better
          await E.audio.play();
        } else {
          playAfterLoad = true;
          E.audio.addEventListener('canplay', () => {
            if (playAfterLoad) {
              playAfterLoad = false;
              E.audio.play().catch(console.error);
            }
          }, { once: true });
        }
      } catch (error) {
        console.error('Play error:', error);
        if (error.name === 'AbortError') {
          // Try again after a short delay
          setTimeout(playAudioSafely, 100);
        }
      }
    }

    // Update the togglePlay function to use safe play
    function togglePlay() {
      if (!state.currentSongId) return;

      if (E.audio.paused) {
        playAudioSafely()
          .then(() => {
            updatePlayPauseUI(true);
          })
          .catch(err => {
            console.error("Play failed:", err);
            showToast("Playback failed. Please try again.");
          });
      } else {
        E.audio.pause();
        updatePlayPauseUI(false);
      }
    }

    // Add these event listeners to your audio element initialization
    E.audio.addEventListener('loadstart', () => {
      isAudioLoading = true;
      E.progressSkeleton.style.opacity = "1";  // Keep original loading indicator
    });

    E.audio.addEventListener('canplay', () => {
      isAudioLoading = false;
      E.progressSkeleton.style.opacity = "0";  // Keep original loading indicator
      if (playAfterLoad) {
        playAfterLoad = false;
        playAudioSafely();
      }
    });

    E.audio.addEventListener('error', () => {
      isAudioLoading = false;
      playAfterLoad = false;
      E.progressSkeleton.style.opacity = "0";
    });
    // Initialize when page loads
    document.addEventListener('DOMContentLoaded', initializeAudio);
    /**
     * Update play/pause UI elements
     * @param {boolean} isPlaying - Current playing state
     */
    function updatePlayPauseUI(isPlaying) {
      const miniIcon = E.playButton.querySelector(".material-icons");
      const fullIcon = E.fullPlayButton.querySelector(".material-icons");

      miniIcon.textContent = isPlaying ? "pause_circle" : "play_circle";
      fullIcon.textContent = isPlaying ? "pause" : "play_arrow";

      state.isPlaying = isPlaying;

      if (isPlaying) {
        requestAnimationFrame(syncProgress);
      }
    }

    /**
     * Sync progress between mini and full player
     */
    function syncProgress() {
      if (E.audio.paused) return;

      const current = E.audio.currentTime;
      const duration = E.audio.duration;

      if (duration > 0) {
        const percent = (current / duration) * 100;
        E.progressBar.style.width = `${percent}%`;
        E.fullProgressBar.style.width = `${percent}%`;
      }

      E.currentTime.textContent = formatTime(current);
      E.fullCurrentTime.textContent = formatTime(current);
      E.totalTime.textContent = formatTime(duration);
      E.fullTotalTime.textContent = formatTime(duration);
      idxSyncLyricsWithPlayer();

      requestAnimationFrame(syncProgress);
    }

    /**
     * Reset player UI to loading state
     */
    function resetPlayerUI() {
      E.fullPlayerTitle.innerHTML = "<span>Spinning The CD</span>";
      E.fullPlayerArtist.textContent = "Loading The Music CD";
      E.fullPlayerArt.src = "/static/images/loading.png"; // Make sure this path is correct

      // Updated lyrics part:
      // This ensures the #lyrics-lines div is present and shows a loading message.
      if (E.lyricsContainer) { // E.lyricsContainer is the scrollable div with id="lyricsContainer"
        let linesDiv = E.lyricsContainer.querySelector('#lyrics-lines');
        if (!linesDiv) { // If it was wiped out or not yet created by lyrics script
          E.lyricsContainer.innerHTML = ''; // Clear it first
          linesDiv = document.createElement('div');
          linesDiv.id = 'lyrics-lines';
          // Apply styles that were in the HTML directly here or ensure CSS covers it
          linesDiv.style.cssText = "display: flex; flex-direction: column; align-items: center; transition: transform 0.3s ease-out;";
          E.lyricsContainer.appendChild(linesDiv);
        }
        linesDiv.innerHTML = '<p class="lyrics-message" style="color: var(--text-secondary); font-style: italic;">Loading lyrics...</p>';
      }

      E.artistImage.src = ""; // Or a placeholder
      E.artistName.textContent = "Loading...";
      E.artistYear.textContent = "Year: -";
      E.artistGenre.textContent = "Genre: -";
      E.progressSkeleton.style.opacity = "1";
    }

    // /**
    //  * Update player info with song details
    //  * @param {Object} info - Song information
    //  */
    // function updatePlayerInfo(info) {
    //   const defaultThumb = '/static/images/default-cover.png';
    //   const externalThumb = `https://i.ytimg.com/vi/${info.id}/default.jpg`;
    //   const thumbnail = info.thumbnail || (info.id.startsWith('local-') ? defaultThumb : externalThumb);

    //   // Update mini player
    //   E.miniPlayerThumb.src = thumbnail;
    //   E.miniPlayerTitle.textContent = info.title || 'Unknown Title';
    //   E.miniPlayerArtist.textContent = info.artist || 'Unknown Artist';

    //   // Update full player
    //   E.fullPlayerArt.src = thumbnail;
    //   E.fullPlayerTitle.innerHTML = `<span>${info.title || 'Unknown Title'}</span>`;
    //   E.fullPlayerArtist.textContent = info.artist || 'Unknown Artist';

    //   document.title = `${info.title} - ${info.artist} | Music Player`;
    //   if ('mediaSession' in navigator) {
    //     navigator.mediaSession.metadata = new MediaMetadata({
    //       title: info.title || 'Unknown Title',
    //       artist: info.artist || 'Unknown Artist',
    //       artwork: [{ src: thumbnail, sizes: '512x512', type: 'image/jpg' }]
    //     });
    //   }
    // }

    /**
 * Update player info with song details
 * @param {Object} info - Song information sent from the backend API
 */
function updatePlayerInfo(info) {
  const defaultThumb = '/static/images/default-cover.png';
  let thumbnail; // Use 'let' as the value will be decided by the logic below

  // Check if the song ID starts with 'uls-', indicating it's a local track.
  if (info.id && info.id.startsWith('uls-')) {
    // For local songs, use the thumbnail_url provided by your backend.
    // Your Python code sends: "thumbnail_url": "/api/thumbnail/local/{song_id}"
    thumbnail = info.thumbnail_url;
  } else {
    // For all other songs (e.g., YouTube), construct the i.ytimg.com URL.
    thumbnail = `/api/v1/thumbnail/${info.id}`;
  }

  // Final fallback: If the thumbnail is still not set for any reason, use the default.
  const finalThumbnail = thumbnail || defaultThumb;

  // Update mini player
  E.miniPlayerThumb.src = finalThumbnail;
  E.miniPlayerTitle.textContent = info.title || 'Unknown Title';
  E.miniPlayerArtist.textContent = info.artist || 'Unknown Artist';

  // Update full player
  E.fullPlayerArt.src = finalThumbnail;
  E.fullPlayerTitle.innerHTML = `<span>${info.title || 'Unknown Title'}</span>`;
  E.fullPlayerArtist.textContent = info.artist || 'Unknown Artist';

  // Update document title and media session
  document.title = `${info.title} - ${info.artist} | Music Player`;
  if ('mediaSession' in navigator) {
    navigator.mediaSession.metadata = new MediaMetadata({
      title: info.title || 'Unknown Title',
      artist: info.artist || 'Unknown Artist',
      artwork: [{ src: finalThumbnail, sizes: '512x512', type: 'image/jpeg' }] // Changed type to jpeg for consistency
    });
  }
}

    /**
     * Show play hint for autoplay restriction
     */
    function showPlayHint() {
      const hint = document.createElement('div');
      hint.style.cssText = `
    position: fixed;
    bottom: 120px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--accent-gradient);
    color: white;
    padding: 12px 24px;
    border-radius: 24px;
    font-size: 14px;
    z-index: 1000;
    animation: playHintPulse 2s infinite;
  `;
      hint.textContent = 'ðŸ‘† Click play to start listening';
      document.body.appendChild(hint);

      const removeHint = () => {
        hint.style.animation = 'toastOut 0.3s ease forwards';
        setTimeout(() => hint.remove(), 300);
      };

      document.addEventListener('click', removeHint, { once: true });
      setTimeout(removeHint, 5000);
    }

    /**
     * Sets up all event listeners for the main <audio> element.
     */
    function setupAudioEventListeners() {
      E.audio.addEventListener("loadedmetadata", () => {
        E.totalTime.textContent = formatTime(E.audio.duration);
        E.fullTotalTime.textContent = formatTime(E.audio.duration);
        E.progressSkeleton.style.opacity = "0";
      });

      E.audio.addEventListener("playing", () => {
        state.isPlaying = true;
        updatePlayPauseUI(true);
      });

      E.audio.addEventListener("pause", async () => {
        state.isPlaying = false;
        updatePlayPauseUI(false);
        // The following lines have been removed to prevent premature session ending:
        /*
        if (currentListenId) {
            await endListeningSession(
                Math.round(E.audio.duration),
                Math.round(E.audio.currentTime)
            );
        }
        */
      });

      E.audio.addEventListener("ended", async () => {
        // **HISTORY FIX**: Ensure session ends when the song finishes.
        await endListeningSession(
          Math.round(E.audio.duration),
          Math.round(E.audio.currentTime)
        );

        state.isPlaying = false;
        updatePlayPauseUI(false);

        const historyModal = document.getElementById('historyModal');
        if (historyModal && historyModal.style.display === 'block') {
          loadHistory(true);
        }

        playNext();
      });

      E.audio.addEventListener("error", (e) => {
        console.error("Audio error:", e);
        showToast("Error playing audio. Please try again.");
      });
    }

    /**
     * Enhanced Music Player - Complete JavaScript Implementation
     * =======================================================
     *
     * PART 4: Queue Management & Search Functionality
     */

    /**
     * Queue Management Functions
     * Handles song queue and playback sequence
     */

    /**
     * Add song to queue and play
     * @param {string} songId - ID of song to queue and play
     */
    async function queueAndPlaySong(songId) {
      // Reset queue if it's too large
      if (state.queue.length > state.maxQueueSize) {
        state.queue = [];
        state.queueIndex = -1;
      }

      addToQueue(songId);
      state.queueIndex = state.queue.indexOf(songId);

      await loadAndPlay(songId);

      // Preload recommendations
      try {
        const response = await fetch(`/api/get-recommendations/${songId}`);
        const recommendations = await response.json();

        if (Array.isArray(recommendations)) {
          recommendations.forEach(song => {
            if (!state.queue.includes(song.id)) {
              state.queue.push(song.id);
            }
          });
        }
      } catch (error) {
        console.error("Error prefetching recommendations:", error);
      }
    }

    /**
     * Add song to queue
     * @param {string} songId - ID of song to add
     */
    function addToQueue(songId) {
      if (!state.queue.includes(songId)) {
        state.queue.push(songId);
      }
    }

    /**
     * Play next song in queue
     */
    async function playNext() {
      if (!state.currentSongId) return;

      // Try queue first
      if (state.queueIndex < state.queue.length - 1) {
        state.queueIndex++;
        await loadAndPlay(state.queue[state.queueIndex]);
        return;
      }

      try {
        const response = await fetch(`/api/play-sequence/${state.currentSongId}/next`);
        const data = await response.json();

        if (response.status === 404) {
          return; // No next song
        }

        if (data.error) {
          console.warn("Next song error:", data.error);
          return;
        }

        // Handle both single song and recommendations array
        const nextSongs = Array.isArray(data) ? data : [data];

        // Add new songs to queue
        nextSongs.forEach(song => {
          if (!state.queue.includes(song.id)) {
            state.queue.push(song.id);
          }
        });

        const nextSongId = nextSongs[0].id;
        state.queueIndex = state.queue.indexOf(nextSongId);
        await loadAndPlay(nextSongId);

      } catch (error) {
        console.error("Error playing next:", error);
        showToast("Failed to play next song");
      }
    }

    /**
     * Play previous song in queue
     */
    async function playPrevious() {
      if (!state.currentSongId) return;

      // Try queue first
      if (state.queueIndex > 0) {
        state.queueIndex--;
        await loadAndPlay(state.queue[state.queueIndex]);
        return;
      }

      try {
        const response = await fetch(`/api/play-sequence/${state.currentSongId}/previous`);
        const data = await response.json();

        if (response.status === 404) {
          // If no previous song, restart current song if played for a while
          if (E.audio.currentTime > 3) {
            E.audio.currentTime = 0;
          }
          return;
        }

        if (data.error) {
          if (E.audio.currentTime > 3) {
            E.audio.currentTime = 0;
          }
          return;
        }

        // Add to queue if not exists
        if (!state.queue.includes(data.id)) {
          state.queue.splice(state.queueIndex, 0, data.id);
        }

        state.queueIndex = state.queue.indexOf(data.id);
        await loadAndPlay(data.id);

      } catch (error) {
        console.error("Error playing previous:", error);
        if (E.audio.currentTime > 3) {
          E.audio.currentTime = 0;
        }
      }
    }

    /**
     * Search Functionality
     * Handles search and results display
     */

    /**
     * Load search results with deduplication
     * @param {boolean} reset - Whether to reset search state
     */
    async function loadSearchResults(reset = false) {
      if (reset) {
        state.searchPage = 0;
        state.searchHasMore = true;
        E.resultsContainer.innerHTML = "";
        state.displayedItems.clear();
      }

      if (!state.searchHasMore || state.loadingMore) return;

      state.loadingMore = true;
      E.infiniteLoader.style.display = "block";

      if (state.searchPage === 0) {
        showSkeleton();
      }

      try {
        const q = encodeURIComponent(state.searchQuery);
        const page = state.searchPage;
        const limit = state.searchLimit;
        const res = await fetch(`/api/search?q=${q}&page=${page}&limit=${limit}`);
        const newResults = await res.json();

        if (state.searchPage === 0) {
          E.resultsContainer.innerHTML = ""; // Clear only on reset
        }

        if (!Array.isArray(newResults) || newResults.length === 0) {
          state.searchHasMore = false;
          if (state.searchPage === 0) {
            E.resultsContainer.innerHTML = "<p>No results found.</p>";
          }
        } else {
          // Create a set of new result IDs for comparison
          const newIds = new Set(newResults.map(song => song.id));

          // Remove results no longer in the new list (only if not resetting)
          if (!reset) {
            const currentItems = E.resultsContainer.querySelectorAll('.result-item');
            currentItems.forEach(item => {
              const songId = item.dataset.id;
              if (!newIds.has(songId) && state.displayedItems.has(songId)) {
                item.remove();
                state.displayedItems.delete(songId);
              }
            });
          }

          // Append only new, unique results
          newResults.forEach(song => {
            if (!state.displayedItems.has(song.id)) {
              displayResults([song]); // Pass single song as array
              state.displayedItems.add(song.id);
            }
          });

          // Update pagination
          state.searchPage += 1;
          state.searchHasMore = newResults.length === state.searchLimit;
        }
      } catch (error) {
        console.error("Error loading search results:", error);
        showToast("Failed to load results. Please try again.", "error");
      } finally {
        state.loadingMore = false;
        E.infiniteLoader.style.display = "none";
      }
    }
    /**
   * Display search results with deduplication, playback indicators, and event handlers.
   * This version includes a 'song-status-indicator' for Celery processing feedback.
   * @param {Array} items - Array of song items to display.
   */
    function displayResults(items) {
      // Filter out items that are already displayed to prevent duplicates.
      const uniqueItems = items.filter(song => {
        // isItemDisplayed uses multiple signatures (ID, title-artist, etc.) to check for duplicates.
        if (isItemDisplayed(song)) {
          return false;
        }

        // If the item is new, add its signatures to the tracking set to prevent future duplication.
        const signatures = [
          song.id,
          `${song.title}-${song.artist}`.toLowerCase().trim(),
          song.title.toLowerCase().trim(),
          `${song.title}-${song.artist}`.toLowerCase().replace(/[^\w\s-]/g, '').trim()
        ];
        signatures.forEach(sig => state.displayedItems.add(sig));
        return true;
      });

      // If there are no new unique items to display, exit the function.
      if (uniqueItems.length === 0) {
        return;
      }

      // Generate the HTML for each new song card.
      const html = uniqueItems.map(song => `
        <div class="song-card ${song.id === state.currentSongId ? 'playing' : ''}" data-id="${song.id}">
            <div class="song-status-indicator"></div>

            <div class="song-thumbnail-container">
                <img class="song-thumbnail"
                     loading="lazy"
                     src="${song.thumbnail || "/static/images/default-cover.png"}"
                     alt="${song.title}"
                     onerror="this.src='/static/images/default-cover.png';">
                <div class="song-duration">${formatTime(song.duration)}</div>
            </div>
            <div class="song-info">
                <div class="song-title">${song.title}</div>
                <div class="song-artist">${song.artist}</div>
            </div>
        </div>
    `).join("");

      // Append the newly created HTML to the results container.
      E.resultsContainer.insertAdjacentHTML("beforeend", html);

      // Add click event handlers to the newly added song cards.
      // We select only cards that haven't had a listener attached yet to avoid duplication.
      document.querySelectorAll(".song-card:not([data-listener='true'])").forEach(card => {
        // Mark the card with a 'data-listener' attribute to signify the handler has been attached.
        card.dataset.listener = "true";
        card.addEventListener("click", () => {
          const songId = card.dataset.id;
          // The queueAndPlaySong function now handles the entire async download and play logic.
          queueAndPlaySong(songId);
        });
      });
    }
    /**
     * Check if a song is already displayed in the results
     * Uses multiple methods to detect duplicates
     * @param {Object} item - Song object to check
     * @returns {boolean} Whether the item is already displayed
     */
    function isItemDisplayed(item) {
      // Create a unique signature for the item that considers multiple factors
      const signatures = [
        // Basic ID check
        item.id,

        // Title + Artist normalized signature
        `${item.title}-${item.artist}`.toLowerCase().trim(),

        // Title-only normalized signature (for covers/remixes)
        item.title.toLowerCase().trim(),

        // Clean-text signature (removes special characters)
        `${item.title}-${item.artist}`
          .toLowerCase()
          .replace(/[^\w\s-]/g, '')
          .trim()
      ];

      // Check if any signature exists in our tracking set
      return signatures.some(sig => state.displayedItems.has(sig));
    }

    /**
     * Format time in seconds to MM:SS format
     * @param {number} seconds - Time in seconds to format
     * @returns {string} Formatted time string
     */
    function formatTime(seconds) {
      if (!seconds || isNaN(seconds)) return "0:00";

      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${mins}:${secs.toString().padStart(2, "0")}`;
    }

    /**
     * Update the visual indicator on song cards to show which song is playing
     * @param {string} songId - ID of currently playing song
     */
    function updatePlayingIndicator(songId) {
      // Remove playing class from all cards
      document.querySelectorAll('.song-card.playing').forEach(card => {
        card.classList.remove('playing');
      });

      // Add playing class to the current song cards
      if (songId) {
        document.querySelectorAll(`.song-card[data-id="${songId}"]`).forEach(card => {
          card.classList.add('playing');
        });
      }
    }



    // /**
    //  * Load and play a song by ID
    //  * Handles all aspects of song playback including:
    //  * - Fetching song metadata
    //  * - Loading audio stream
    //  * - Starting listening session
    //  * - Updating UI elements
    //  * - Managing playback state
    //  * - Updating song cards with playback indicators
    //  * 
    //  * @param {string} songId - ID of song to load and play
    //  */
    // /**
    //  * Main function to load and play a song. Handles the entire async workflow.
    //  * @param {string} songId - The ID of the song to play.
    //  */
    // async function loadAndPlay(songId) {
    //   if (!songId) return;

    //   if (songId === state.currentSongId && !E.audio.paused) {
    //     togglePlay();
    //     return;
    //   }

    //   if (state.processingTasks.has(songId)) {
    //     showNotification('info', 'Processing...', 'This song is being prepared.');
    //     return;
    //   }

    //   // End the previous listening session to log it to history.
    //   if (state.currentSongId && currentListenId && !E.audio.paused) {
    //     await endListeningSession(Math.round(E.audio.duration), Math.round(E.audio.currentTime));
    //   }

    //   state.currentSongId = songId;
    //   resetPlayerUI();
    //   updatePlayingIndicator(songId, 'loading');

    //   try {
    //     const downloadUrl = `/api/download/${songId}`;

    //     const response = await fetch(downloadUrl);

    //     // If the server returns JSON, a background task has started.
    //     if (response.headers.get("content-type")?.includes("application/json")) {
    //       const data = await response.json();
    //       if (data.status === 'processing' && data.task_id) {
    //         state.processingTasks.add(songId);
    //         updatePlayingIndicator(songId, 'processing');
    //         showNotification('info', 'Preparing Song', 'This may take a moment...');
    //         pollTaskStatus(data.task_id, songId);
    //       } else {
    //         throw new Error(data.error || 'Failed to start song processing.');
    //       }
    //       return;
    //     }

    //     const blob = await response.blob();
    //     const objectURL = URL.createObjectURL(blob);
    //     E.audio.src = objectURL;

    //     // **CRITICAL FIX**: Fetch song info *before* updating the UI.
    //     const infoResponse = await fetch(`/api/song-info/${songId}`);
    //     const infoData = await infoResponse.json();
    //     if (infoData.error) throw new Error(infoData.error);

    //     // Now, call the centralized UI updater with the correct song info.
    //     updatePlayerAndRelatedInfo(infoData);

    //     await E.audio.play();
    //     updatePlayPauseUI(true);

    //   } catch (e) {
    //     console.error("loadAndPlay error:", e);
    //     showNotification('error', 'Playback Error', e.message);
    //     resetPlayerUI();
    //     updatePlayingIndicator(null);
    //     state.processingTasks.delete(songId);
    //   }
    // }
//   async function loadAndPlay(songId) {
//   if (!songId) return;

//   // If the same song is already playing, toggle play/pause.
//   if (songId === state.currentSongId && !E.audio.paused) {
//     togglePlay();
//     return;
//   }

//   // If the song is currently being processed, notify the user and return.
//   if (state.processingTasks.has(songId)) {
//     showNotification('info', 'Processing...', 'This song is being prepared.');
//     return;
//   }

//   // End the previous listening session if a song was playing.
//   if (state.currentSongId && currentListenId && !E.audio.paused) {
//     await endListeningSession(Math.round(E.audio.duration), Math.round(E.audio.currentTime));
//   }

//   state.currentSongId = songId;
//   resetPlayerUI();
//   updatePlayingIndicator(songId, 'loading');

//   try {
//     // --- MODIFIED CODE BLOCK START (Refined Stream Consumption) ---
//     const streamResponse = await fetch(`/api/play/${songId}`);

//     // Check if the response itself is OK (e.g., not a 404 or 500).
//     if (!streamResponse.ok) {
//       const errorText = await streamResponse.text(); // Read body ONCE for error message
//       throw new Error(`Server error getting stream URL (${streamResponse.status}): ${errorText}`);
//     }

//     const streamData = await streamResponse.json(); // Read body ONCE as JSON

//     // Handle processing status returned by the server.
//     if (streamData.status === 'processing' && streamData.task_id) {
//       state.processingTasks.add(songId);
//       updatePlayingIndicator(songId, 'processing');
//       showNotification('info', 'Preparing Song', 'This may take a moment...');
//       pollTaskStatus(streamData.task_id, songId);
//       return; // Exit as the polling function will handle playback after processing.
//     }

//     // Ensure a URL is present in the successful JSON response.
//     if (!streamData.url) {
//       throw new Error('Stream URL not provided in server response.');
//     }

//     E.audio.src = streamData.url; // Set the audio source directly.
//     // --- MODIFIED CODE BLOCK END ---

//     // Fetch song info to update player UI. This is a separate fetch call.
//     const infoResponse = await fetch(`/api/song-info/${songId}`);
//     const infoData = await infoResponse.json(); // This specific line caused the error.
//                                                 // It should now work as infoResponse is a fresh stream.
//     if (infoData.error) throw new Error(infoData.error);

//     // Update all relevant UI elements with the new song info.
//     updatePlayerAndRelatedInfo(infoData);

//     // Attempt to play the audio.
//     await E.audio.play();
//     updatePlayPauseUI(true);

//   } catch (e) {
//     console.error("loadAndPlay error:", e);
//     showNotification('error', 'Playback Error', e.message);
//     resetPlayerUI();
//     updatePlayingIndicator(null);
//     state.processingTasks.delete(songId); // Clear processing status on error.
//   }
// }
async function loadAndPlay(songId) {
  if (!songId) return;

  // If the same song is already playing, toggle play/pause.
  if (songId === state.currentSongId && !E.audio.paused) {
    togglePlay();
    return;
  }

  // If the song is currently being processed, notify the user and return.
  if (state.processingTasks.has(songId)) {
    showNotification('info', 'Processing...', 'This song is being prepared.');
    return;
  }

  // End the previous listening session if a song was playing.
  if (state.currentSongId && currentListenId && !E.audio.paused) {
    await endListeningSession(Math.round(E.audio.duration), Math.round(E.audio.currentTime));
  }

  state.currentSongId = songId;
  resetPlayerUI();
  updatePlayingIndicator(songId, 'loading');

  try {
    const streamResponse = await fetch(`/api/download/${songId}`); // This calls the download endpoint

    if (!streamResponse.ok) {
      const errorText = await streamResponse.text();
      throw new Error(`Server error (${streamResponse.status}): ${errorText}`);
    }

    const contentType = streamResponse.headers.get("Content-Type"); // Get the Content-Type header

    if (contentType && contentType.includes("application/json")) {
      // If it's JSON, it could be a processing status or a stream URL wrapper
      const data = await streamResponse.json(); // Safely parse as JSON

      if (data.status === 'processing' && data.task_id) {
        state.processingTasks.add(songId);
        updatePlayingIndicator(songId, 'processing');
        showNotification('info', 'Preparing Song', 'This may take a moment...');
        pollTaskStatus(data.task_id, songId); // Poll the task status
        return; // Exit as polling will handle playback
      } else if (data.url) {
        // If JSON contains a direct URL (e.g., from /api/play or other JSON response)
        E.audio.src = data.url;
      } else {
        throw new Error('Unexpected JSON response format.');
      }
    } else if (contentType && (contentType.includes("audio/") || contentType.includes("application/octet-stream"))) {
      // If it's an audio file (e.g., audio/flac, audio/ogg) or a generic binary stream.
      // As per your request, avoid creating a Blob. Directly use the URL of the response.
      // This works if the URL of the fetch response itself (after any redirects)
      // points directly to a streamable audio file.
      E.audio.src = streamResponse.url;
    } else {
      // Fallback for unexpected content types
      throw new Error('Unexpected response content type: ' + contentType);
    }

    // Fetch song information to update player UI details (separate request).
    // This runs after E.audio.src is set, regardless of how the audio was obtained.
    const infoResponse = await fetch(`/api/song-info/${songId}`);
    const infoData = await infoResponse.json();
    if (infoData.error) throw new Error(infoData.error);

    updatePlayerAndRelatedInfo(infoData);

    await E.audio.play();
    updatePlayPauseUI(true);

  } catch (e) {
    console.error("loadAndPlay error:", e);
    showNotification('error', 'Playback Error', e.message);
    resetPlayerUI();
    updatePlayingIndicator(null);
    state.processingTasks.delete(songId); // Clear processing status on error.
  }
}
    /**
     * Central function to update all relevant UI parts when a new song is loaded.
     * This is the single source of truth for refreshing the player state.
     * @param {object} infoData - The metadata for the new song.
     */
    function updatePlayerAndRelatedInfo(infoData) {
      if (!infoData) return;

      // 1. Update the main player UI (mini and full).
      updatePlayerInfo(infoData);

      // 2. Refresh the lyrics for the new song.
      if (typeof idxStartLyricsForSong === 'function') {
        idxStartLyricsForSong(infoData.id, infoData.title, infoData.artist);
      }

      // 3. Refresh the artist information panel.
      if (typeof SangeetPlayer_ArtistInfo !== 'undefined') {
        SangeetPlayer_ArtistInfo.loadAndDisplayArtistInfo(infoData.artist);
      }

      // 4. Start a new listening session for history and analytics.
      startListeningSession(infoData.id, infoData.title, infoData.artist);

      // 5. If the history modal is currently open, refresh its content.
      const historyModal = document.getElementById('historyModal');
      if (historyModal && historyModal.style.display === 'block' && typeof loadHistory === 'function') {
        loadHistory(true); // Pass true to force a refresh
      }
    }
    // /**
    //  * Polls the Celery task status endpoint.
    //  * @param {string} taskId - The ID of the Celery task.
    //  * @param {string} songId - The ID of the song being processed.
    //  */
    // function pollTaskStatus(taskId, songId) {
    //   const intervalId = setInterval(async () => {
    //     try {
    //       const response = await fetch(`/download-server/api/status/${taskId}`);
    //       const data = await response.json();

    //       if (data.state === 'SUCCESS') {
    //         clearInterval(intervalId);
    //         state.processingTasks.delete(songId);
    //         showNotification('success', 'Song Ready!', 'Your song is now ready to play.');

    //         // **CRITICAL CHANGE: Fetch info and then update everything**
    //         const infoResponse = await fetch(`/api/song-info/${songId}`);
    //         const infoData = await infoResponse.json();
    //         if (infoData.error) throw new Error(infoData.error);

    //         // Now that the song is ready and we have its info, update the UI and play
    //         updatePlayerAndRelatedInfo(infoData);
    //         const downloadedUrl = `/api/download/${songId}`;
    //         E.audio.src = downloadedUrl;
    //         await E.audio.play();
    //         updatePlayPauseUI(true);

    //       } else if (data.state === 'FAILURE') {
    //         clearInterval(intervalId);
    //         state.processingTasks.delete(songId);
    //         updatePlayingIndicator(null);
    //         showNotification('error', 'Download Failed', 'Could not prepare the song.');
    //         console.error('Task failed:', data.status);
    //       }
    //     } catch (error) {
    //       clearInterval(intervalId);
    //       state.processingTasks.delete(songId);
    //       updatePlayingIndicator(null);
    //       console.error('Error polling task status:', error);
    //       showNotification('error', 'Connection Error', 'Lost connection to the server.');
    //     }
    //   }, 3000);
    // }

//     function pollTaskStatus(taskId, songId) {
//   const intervalId = setInterval(async () => {
//     try {
//       const response = await fetch(`/download-server/api/status/${taskId}`);
//       const data = await response.json(); // Read body ONCE

//       if (data.state === 'SUCCESS') {
//         clearInterval(intervalId);
//         state.processingTasks.delete(songId);
//         showNotification('success', 'Song Ready!', 'Your song is now ready to play.');

//         // Fetch song info to update player UI after successful processing.
//         const infoResponse = await fetch(`/api/song-info/${songId}`);
//         const infoData = await infoResponse.json(); // Read body ONCE
//         if (infoData.error) throw new Error(infoData.error);

//         // Update all relevant UI elements with the new song info.
//         updatePlayerAndRelatedInfo(infoData);

//         // --- MODIFIED CODE BLOCK START ---
//         // Now that processing is complete, fetch the direct streaming URL.
//         const streamResponse = await fetch(`/api/play/${songId}`);
//         if (!streamResponse.ok) {
//           const errorText = await streamResponse.text(); // Read body ONCE for error
//           throw new Error(`Failed to get stream URL after processing: ${errorText}`);
//         }
//         const streamData = await streamResponse.json(); // Read body ONCE
//         // --- MODIFIED CODE BLOCK END ---

//         // Ensure a URL is present.
//         if (!streamData.url) {
//             throw new Error('Stream URL not provided after processing completion.');
//         }

//         E.audio.src = streamData.url; // Set audio source directly.
//         await E.audio.play();
//         updatePlayPauseUI(true);

//       } else if (data.state === 'FAILURE') {
//         clearInterval(intervalId);
//         state.processingTasks.delete(songId);
//         updatePlayingIndicator(null);
//         showNotification('error', 'Download Failed', 'Could not prepare the song.');
//         console.error('Task failed:', data.status);
//       }
//     } catch (error) {
//       clearInterval(intervalId);
//       state.processingTasks.delete(songId);
//       updatePlayingIndicator(null);
//       console.error('Error polling task status:', error);
//       showNotification('error', 'Connection Error', 'Lost connection to the server.');
//     }
//   }, 3000);
// }

function pollTaskStatus(taskId, songId) {
  // Use a named function for setInterval callback for clarity and potential debugging
  const pollIntervalCallback = async () => {
    try {
      const response = await fetch(`/download-server/api/status/${taskId}`);
      const data = await response.json(); // Read body ONCE

      if (data.state === 'SUCCESS') {
        clearInterval(intervalId); // Stop polling
        state.processingTasks.delete(songId);
        // This toast should show when the song is successfully prepared.
        showNotification('success', 'Song Ready!', 'Your song is now ready to play.');

        // Fetch song information to update player UI after successful processing.
        const infoResponse = await fetch(`/api/song-info/${songId}`);
        const infoData = await infoResponse.json(); // Read body ONCE
        if (infoData.error) throw new Error(infoData.error);

        // Update all relevant UI elements with the new song information.
        updatePlayerAndRelatedInfo(infoData);

        // Fetch the direct streaming URL now that processing is complete.
        const streamResponse = await fetch(`/api/play/${songId}`);
        if (!streamResponse.ok) {
          const errorText = await streamResponse.text(); // Read body ONCE for error
          throw new Error(`Failed to get stream URL after processing: ${errorText}`);
        }
        const streamData = await streamResponse.json(); // Read body ONCE

        // Ensure a URL is present in the stream data.
        if (!streamData.url) {
            throw new Error('Stream URL not provided after processing completion.');
        }

        E.audio.src = streamData.url; // Set audio source directly.
        await E.audio.play();
        updatePlayPauseUI(true);

      } else if (data.state === 'FAILURE') {
        clearInterval(intervalId); // Stop polling
        state.processingTasks.delete(songId);
        updatePlayingIndicator(null);
        showNotification('error', 'Download Failed', 'Could not prepare the song.');
        console.error('Task failed:', data.status);
      }
    } catch (error) {
      clearInterval(intervalId); // Stop polling on error
      state.processingTasks.delete(songId);
      updatePlayingIndicator(null);
      console.error('Error polling task status:', error);
      showNotification('error', 'Connection Error', 'Lost connection to the server.');
    }
  };

  const intervalId = setInterval(pollIntervalCallback, 3000); // Poll every 3 seconds
}
    /**
     * Play audio safely with proper loading state handling
     * Ensures audio plays correctly regardless of loading state
     */
    async function playAudioSafely() {
      try {
        if (isAudioLoading) {
          playAfterLoad = true;
          return;
        }

        if (E.audio.readyState >= 2) { // HAVE_CURRENT_DATA or better
          await E.audio.play();
        } else {
          playAfterLoad = true;
          E.audio.addEventListener('canplay', () => {
            if (playAfterLoad) {
              playAfterLoad = false;
              E.audio.play().catch(console.error);
            }
          }, { once: true });
        }
      } catch (error) {
        console.error('Play error:', error);
        if (error.name === 'AbortError') {
          // Try again after a short delay
          setTimeout(playAudioSafely, 100);
        }
      }
    }

    /**
     * Update the visual indicator on song cards to show which song is playing
     * @param {string} songId - ID of currently playing song
     */
    function updatePlayingIndicator(songId, status = 'playing') {
      // Remove playing/processing classes from all cards
      document.querySelectorAll('.song-card').forEach(card => {
        card.classList.remove('playing', 'processing');
        const indicator = card.querySelector('.song-status-indicator');
        if (indicator) indicator.textContent = '';
      });

      if (songId) {
        document.querySelectorAll(`.song-card[data-id="${songId}"]`).forEach(card => {
          const indicator = card.querySelector('.song-status-indicator');
          if (status === 'processing') {
            card.classList.add('processing');
            if (indicator) indicator.textContent = 'Processing...';
          } else {
            card.classList.add('playing');
            if (indicator) indicator.textContent = ''; // Clear text when playing
          }
        });
      }
    }
    /**
     * Show skeleton loading animation
     */
    function showSkeleton() {
      E.resultsContainer.innerHTML = Array(6).fill("")
        .map(() => `<div class="song-card skeleton"></div>`)
        .join("");
    }

    /**
     * Check if item is already displayed
     * @param {Object} item - Song item to check
     * @returns {boolean} Whether item is already displayed
     */
    // Enhanced isItemDisplayed function with better duplicate detection
    function isItemDisplayed(item) {
      // Create a unique signature for the item that considers multiple factors
      const signatures = [
        // Basic ID check
        item.id,

        // Title + Artist normalized signature
        `${item.title}-${item.artist}`.toLowerCase().trim(),

        // Title-only normalized signature (for covers/remixes)
        item.title.toLowerCase().trim(),

        // Clean-text signature (removes special characters)
        `${item.title}-${item.artist}`
          .toLowerCase()
          .replace(/[^\w\s-]/g, '')
          .trim()
      ];

      // Check if any signature exists in our tracking set
      return signatures.some(sig => state.displayedItems.has(sig));
    }

    // Enhanced displayResults function with improved deduplication
    function displayResults(items) {
      const uniqueItems = items.filter(song => {
        if (isItemDisplayed(song)) {
          return false;
        }

        // Add all signatures to tracking set
        const signatures = [
          song.id,
          `${song.title}-${song.artist}`.toLowerCase().trim(),
          song.title.toLowerCase().trim(),
          `${song.title}-${song.artist}`
            .toLowerCase()
            .replace(/[^\w\s-]/g, '')
            .trim()
        ];

        signatures.forEach(sig => state.displayedItems.add(sig));
        return true;
      });

      // Rest of the display logic...
      if (uniqueItems.length === 0) return;

      const html = uniqueItems.map(song => `
    <div class="song-card" data-id="${song.id}">
      <div class="song-thumbnail-container">
        <img class="song-thumbnail"
             loading="lazy"
             src="${song.thumbnail || "/static/images/default-cover.png"}"
             alt="${song.title}">
        <div class="song-duration">${formatTime(song.duration)}</div>
      </div>
      <div class="song-info">
        <div class="song-title">${song.title}</div>
        <div class="song-artist">${song.artist}</div>
      </div>
    </div>
  `).join("");

      E.resultsContainer.insertAdjacentHTML("beforeend", html);

      // Add click handlers
      document.querySelectorAll(".song-card").forEach(card => {
        if (!card.hasListener) {
          card.hasListener = true;
          card.addEventListener("click", () => {
            const sid = card.dataset.id;
            queueAndPlaySong(sid);
          });
        }
      });
    }

    // Reset function to clear tracking when starting new search
    function resetSearchState() {
      state.searchPage = 0;
      state.searchHasMore = true;
      E.resultsContainer.innerHTML = "";
      state.displayedItems.clear();
    }

    // Debounced search function
    const doSearch = debounce(() => {
      state.searchQuery = E.searchInput.value.trim();
      loadSearchResults(true);
    }, 400);

    // Search input handler
    E.searchInput.addEventListener("input", () => {
      if (E.searchInput.value.trim()) {
        E.broomIcon.style.display = "block";
      } else {
        E.broomIcon.style.display = "none";
        state.displayedItems.clear();
      }
      doSearch();
    });

    // Clear search handler
    E.broomIcon.addEventListener("click", () => {
      E.searchInput.value = "";
      E.broomIcon.style.display = "none";
      state.displayedItems.clear();
      doSearch();
    });
    /**
     * Enhanced Music Player - Complete JavaScript Implementation
     * =======================================================
     *
     * PART 5: Initialization and Event Bindings
     */

    /**
     * Setup all event listeners
     * Initializes all event handlers for the application
     */
    function setupEventListeners() {
      // Keyboard shortcuts
      document.addEventListener("keydown", e => {
        // if (e.code === "Space" && e.target === document.body) {
        //   e.preventDefault();
        //   togglePlay();
        // }
        // if (e.code === "Space" && e.target !== E.searchInput) {
        //   e.preventDefault();
        //   togglePlay();
        // }
        const isTypingElement = e.target && (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable);

        if (e.code === "Space" && !isTypingElement) { // Check if space is pressed AND we are NOT typing in an input/textarea
          e.preventDefault(); // Prevent default ONLY when not typing (e.g., prevent page scroll)
          togglePlay();
        }
        if ((e.code === "ArrowLeft" || e.key === ",") && (e.ctrlKey || e.shiftKey)) {
          e.preventDefault();
          playPrevious();
        }
        if ((e.code === "ArrowRight" || e.key === ".") && (e.ctrlKey || e.shiftKey)) {
          e.preventDefault();
          playNext();
        }
        if (e.code === "Escape") {
          E.fullPlayer.classList.remove("active");
        }
      });

      // Mini player controls
      E.playButton.addEventListener('click', togglePlay);
      E.prevButton.addEventListener('click', playPrevious);
      E.nextButton.addEventListener('click', playNext);

      // Full player controls
      E.fullPlayButton.addEventListener('click', togglePlay);
      E.fullPrevButton.addEventListener('click', playPrevious);
      E.fullNextButton.addEventListener('click', playNext);

      // Volume control
      E.volumeSlider.addEventListener("input", handleVolumeChange);
      E.volumeButton.addEventListener("click", toggleMute);

      // Player expand/minimize
      E.expandButton.addEventListener("click", () => {
        E.fullPlayer.classList.add("active");
      });

      E.minimizeButton.addEventListener("click", () => {
        E.fullPlayer.classList.remove("active");
      });

      // Define the debounced loadMore function
      const loadMoreDebounced = debounce(() => {
        if (!state.loadingMore && state.searchHasMore) {
          loadSearchResults(false);
        }
      }, 200);

      // Update scroll event listener
      window.addEventListener('scroll', () => {
        const { scrollTop, scrollHeight, clientHeight } = document.documentElement;
        if (scrollTop + clientHeight >= scrollHeight - 100) {
          loadMoreDebounced();
        }
      });

      // Window focus handling
      window.addEventListener('focus', () => {
        // Resume progress tracking if playing
        if (state.isPlaying) {
          requestAnimationFrame(syncProgress);
        }
      });
    }

    async function setupInitialSong() {
      const urlParams = new URLSearchParams(window.location.search);
      const sharedSongId = urlParams.get('song');
      let songToPreload = null;

      try {
        if (sharedSongId) {
          const response = await fetch(`/api/song-info/${sharedSongId}`);
          songToPreload = await response.json();
        } else {
          songToPreload = await getRandomSong();
        }

        if (songToPreload && songToPreload.id) {
          state.currentSongId = songToPreload.id;
          E.miniPlayer.classList.remove("hidden");

          // **Use the new centralized UI updater**
          updatePlayerAndRelatedInfo(songToPreload);

          // Preload audio
          const streamData = await fetch(`/api/play/${songToPreload.id}`).then(r => r.json());
          if (!streamData.error) {
            E.audio.src = streamData.url;
            E.audio.load();
          }

          if (!state.queue.includes(songToPreload.id)) {
            state.queue.push(songToPreload.id);
            state.queueIndex = state.queue.length - 1;
          }

          showPlayHint();
          if (sharedSongId) {
            history.replaceState({}, '', window.location.pathname);
          }
        }
      } catch (error) {
        console.error("Error setting up initial song:", error);
        showToast("Failed to load initial song");
      }
    }

    /**
     * Initialize application settings
     */
    // Updated initializeSettings function with proper audio context handling
    // 1. Fix AudioContext initialization
    function initializeAudioContext() {
      let audioContext;

      // Create context only after user interaction
      document.addEventListener('click', function initContext() {
        if (!audioContext) {
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          if (AudioContext) {
            audioContext = new AudioContext();
            // Remove listener after first click
            document.removeEventListener('click', initContext);
          }
        }
      }, { once: true });

      return audioContext;
    }

    // 2. Fix setupInsights with null checks
    function setupInsights() {
      const insightsButton = document.querySelector('.player-controls .control-button[title="View Insights"]');
      const insightsModal = document.getElementById('insightsModal');
      const closeInsights = document.getElementById('closeInsights');

      if (!insightsButton || !insightsModal || !closeInsights) {
        console.warn('Insights elements not found, skipping setup');
        return;
      }

      insightsButton.addEventListener('click', async () => {
        insightsModal.style.display = 'block';
        await loadInsights();
      });

      closeInsights.addEventListener('click', () => {
        insightsModal.style.display = 'none';
      });
    }



    // 4. Update initialization function
    async function init() {
      try {
        // Initialize base settings with delayed AudioContext
        initializeSettings();

        // Setup all event listeners
        setupEventListeners();
        setupAudioEventListeners();

        // Initialize components with error handling
        setupSpeechRecognition();
        initializePlayerControls();
        checkProtocolAndShowWarning();


        // Initialize charts first
        const chartsInitialized = await initializeCharts();

        // Only setup insights if charts initialized successfully
        if (chartsInitialized) {
          setupInsights();
        }

        // Setup progress bars
        setupProgressBar(E.progressContainer, E.progressHover);
        setupProgressBar(E.fullProgressContainer, E.fullProgressHover);

        // Load initial song
        await setupInitialSong();

        // Load initial search results
        state.searchQuery = "";
        await loadSearchResults(true);


      } catch (error) {
        console.error("Initialization error:", error);
        showToast("An error occurred during initialization");
      }
    }

    // 5. Update initializeSettings function
    function initializeSettings() {
      // Set initial volume
      const savedVolume = localStorage.getItem("player-volume");
      if (savedVolume) {
        state.volume = parseInt(savedVolume);
        E.volumeSlider.value = state.volume;
        E.audio.volume = state.volume / 100;
        updateVolumeIcon(state.volume);
      }

      // Setup audio quality with delayed initialization
      let audioContext;
      document.addEventListener('click', () => {
        if (!audioContext && (window.AudioContext || window.webkitAudioContext)) {
          try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            if (audioContext?.audioWorklet) {
              setupAudioWorklet(audioContext).catch(console.warn);
            }
          } catch (err) {
            console.warn('AudioContext initialization failed:', err);
          }
        }
      }, { once: true });

      // Setup player appearance from preferences
      const savedTheme = localStorage.getItem("player-theme");
      if (savedTheme) {
        document.documentElement.setAttribute('data-theme', savedTheme);
      }
    }

    /**
     * Main initialization function
     * Entry point for the application
     */
    async function init() {
      try {
        // Initialize base settings
        initializeSettings();

        // Setup all event listeners
        setupEventListeners();
        setupAudioEventListeners();

        // Initialize components
        setupSpeechRecognition();
        initializePlayerControls();
        showToast("Welcome To Sangeet Premium Plus...")
        await initializeCharts();
        setupInsights(); // Move setupInsights here

        // Setup progress bars
        setupProgressBar(E.progressContainer, E.progressHover);
        setupProgressBar(E.fullProgressContainer, E.fullProgressHover);

        // Load initial song
        await setupInitialSong();

        // Load initial search results
        state.searchQuery = "";
        await loadSearchResults(true);

      } catch (error) {
        console.error("Initialization error:", error);
        showToast("An error occurred during initialization");
      }
    }
    // Initialize all charts for the insights view
    async function initializeCharts() {
      try {
        // Create container divs for charts if they don't exist
        const chartContainers = ['dailyPatternChart', 'hourlyPatternChart', 'completionChart'];

        chartContainers.forEach(containerId => {
          const container = document.getElementById(containerId);
          if (container) {
            // Clear existing content
            container.innerHTML = '';
            // Add canvas element
            const canvas = document.createElement('canvas');
            canvas.id = `${containerId}Canvas`;
            container.appendChild(canvas);
          }
        });

        // Initialize empty charts with default configurations
        const ctx = {
          daily: document.getElementById('dailyPatternChartCanvas')?.getContext('2d'),
          hourly: document.getElementById('hourlyPatternChartCanvas')?.getContext('2d'),
          completion: document.getElementById('completionChartCanvas')?.getContext('2d')
        };

        // Only proceed if Chart.js is loaded
        if (!window.Chart) {
          console.warn('Chart.js not loaded yet');
          return false;
        }

        // Set default chart options
        Chart.defaults.color = '#94a3b8';
        Chart.defaults.font.family = 'system-ui, sans-serif';
        Chart.defaults.plugins.legend.display = false;
        Chart.defaults.animation.duration = 2000;
        Chart.defaults.elements.line.tension = 0.4;

        // Initialize empty charts
        if (ctx.daily) {
          window.chartInstances = window.chartInstances || {};
          window.chartInstances.daily = new Chart(ctx.daily, {
            type: 'bar',
            data: {
              labels: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
              datasets: [{
                data: Array(7).fill(0),
                backgroundColor: 'rgba(79,70,229,0.2)',
                borderColor: 'rgba(79,70,229,0.8)',
                borderWidth: 2,
                borderRadius: 4
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: {
                  beginAtZero: true,
                  grid: {
                    color: 'rgba(148,163,184,0.1)'
                  }
                },
                x: {
                  grid: {
                    display: false
                  }
                }
              }
            }
          });
        }

        if (ctx.hourly) {
          window.chartInstances.hourly = new Chart(ctx.hourly, {
            type: 'line',
            data: {
              labels: Array.from({ length: 24 }, (_, i) => `${i}:00`),
              datasets: [{
                data: Array(24).fill(0),
                backgroundColor: 'rgba(129,140,248,0.2)',
                borderColor: 'rgba(129,140,248,0.8)',
                borderWidth: 2,
                fill: true
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                y: {
                  beginAtZero: true,
                  grid: {
                    color: 'rgba(148,163,184,0.1)'
                  }
                },
                x: {
                  grid: {
                    display: false
                  }
                }
              }
            }
          });
        }

        if (ctx.completion) {
          window.chartInstances.completion = new Chart(ctx.completion, {
            type: 'doughnut',
            data: {
              labels: ['Complete', 'Partial', 'Skipped'],
              datasets: [{
                data: [0, 0, 0],
                backgroundColor: [
                  'rgba(79,70,229,0.8)',
                  'rgba(129,140,248,0.8)',
                  'rgba(199,210,254,0.8)'
                ],
                borderWidth: 0
              }]
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              cutout: '70%',
              plugins: {
                legend: {
                  display: true,
                  position: 'bottom'
                }
              }
            }
          });
        }

        return true;

      } catch (error) {
        console.error('Error initializing charts:', error);
        return false;
      }
    }
    /**
     * Error handler for uncaught errors
     */
    window.onerror = function (msg, url, line, col, error) {
      console.error("Global error:", { msg, url, line, col, error });
      // showToast("An unexpected error occurred");
      return false;
    };

    /**
     * Handle unhandled promise rejections
     */
    window.onunhandledrejection = function (event) {
      console.error("Unhandled promise rejection:", event.reason);
      showToast("An unexpected error occurred");
    };

    // Start the application
    document.addEventListener("DOMContentLoaded", init);

    // Export functions for potential external use
    window.PlayerAPI = {
      togglePlay,
      playNext,
      playPrevious,
      updateVolume: handleVolumeChange,
      toggleMute,
      seekTo: (time) => {
        if (E.audio.duration) {
          E.audio.currentTime = time;
        }
      }
    };
    /**
     * Lyrics and Artist Info Functions
     * Handles loading and displaying song metadata
     */

    /**
     * Load and display lyrics for a song
     * @param {string} songId - ID of song to load lyrics for
     */
    //      async function loadLyrics(songId) {
    //   // Set loading state
    //   E.lyricsContainer.innerHTML = '<div class="lyrics-line loading">Loading lyrics...</div>';

    //   try {
    //     const response = await fetch(`/api/lyrics/${songId}`);
    //     if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
    //     const lines = await response.json();

    //     // Validate lyrics data
    //     if (!Array.isArray(lines) || !lines.length) {
    //       E.lyricsContainer.innerHTML = `
    //         <div class="lyrics-line no-lyrics">
    //           No lyrics available
    //         </div>`;
    //       return;
    //     }

    //     // Clear container and prepare for new lyrics
    //     E.lyricsContainer.innerHTML = '';

    //     // Add lyrics with staggered animation and enhanced styling
    //     lines.forEach((line, index) => {
    //       const div = document.createElement('div');
    //       div.className = 'lyrics-line';
    //       div.textContent = line.trim() || '\u00A0'; // Use non-breaking space for empty lines
    //       div.dataset.index = index; // For potential future use (e.g., highlighting)

    //       // Initial state for animation
    //       div.style.opacity = '0';
    //       div.style.transform = 'translateY(20px)';
    //       div.style.transition = 'none'; // Prevent premature transitions

    //       E.lyricsContainer.appendChild(div);

    //       // Trigger animation with delay
    //       setTimeout(() => {
    //         div.style.transition = 'all 0.5s ease-out';
    //         div.style.opacity = '1';
    //         div.style.transform = 'translateY(0)';
    //       }, index * 150); // Increased delay for smoother effect
    //     });

    //     // Ensure container has modern styling (fallback if CSS is missing)
    //     E.lyricsContainer.style.background = E.lyricsContainer.style.background || 
    //       'linear-gradient(135deg, rgba(10, 10, 20, 0.95), rgba(40, 40, 60, 0.85))';
    //     E.lyricsContainer.style.borderRadius = '12px';
    //     E.lyricsContainer.style.padding = '20px';
    //     E.lyricsContainer.style.boxShadow = '0 8px 24px rgba(0, 0, 0, 0.2)';
    //     E.lyricsContainer.style.overflowY = 'auto'; // Scroll if too many lines

    //   } catch (error) {
    //     console.error('Error loading lyrics:', error);
    //     E.lyricsContainer.innerHTML = `
    //       <div class="lyrics-line error">
    //         Unable to load lyrics
    //       </div>`;
    //   }
    // }



    /**
     * Get a random song from available songs
     * @returns {Promise<Object>} Random song object
     */
    async function getRandomSong() {
      try {
        const response = await fetch('/api/random-song');
        if (!response.ok) throw new Error('Failed to get random song');
        return await response.json();
      } catch (error) {
        console.error('Error getting random song:', error);
        showToast("Failed to load random song");
        return null;
      }
    }
  </script>
  <script>
    // Add integration button to full player controls
    const integrationButton = document.createElement('button');
    integrationButton.className = 'control-button';
    integrationButton.innerHTML = '<span class="material-icons">code</span>';
    integrationButton.title = 'Get embed code';
    document.querySelector('.full-player .player-controls').appendChild(integrationButton);

    // Integration state
    const integrationState = {
      size: 'normal',
      theme: 'default',
      serverDomain: window.location.origin
    };

    // Add container to full player
    document.getElementById('fullPlayer').insertAdjacentHTML('beforeend', document.getElementById('integrationContainer').outerHTML);

    // Integration handling
    function initializeIntegration() {
      const container = document.getElementById('integrationContainer');
      const closeBtn = document.getElementById('closeIntegration');
      const copyBtn = document.getElementById('copyCode');
      const sizeBtns = container.querySelectorAll('.size-btn');
      const themeBtns = container.querySelectorAll('.theme-btn');

      // Show integration panel
      integrationButton.addEventListener('click', () => {
        container.style.display = 'block';
        updatePreviewAndCode();
      });

      // Close panel
      closeBtn.addEventListener('click', () => {
        container.style.display = 'none';
      });

      // Size selection
      sizeBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          sizeBtns.forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          integrationState.size = btn.dataset.size;
          updatePreviewAndCode();
        });
      });

      // Theme selection
      themeBtns.forEach(btn => {
        btn.addEventListener('click', () => {
          themeBtns.forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          integrationState.theme = btn.dataset.theme;
          updatePreviewAndCode();
        });
      });

      // Copy code
      copyBtn.addEventListener('click', async () => {
        const code = document.getElementById('embedCode').textContent;
        try {
          await navigator.clipboard.writeText(code);
          copyBtn.innerHTML = '<span class="material-icons">check</span>';
          setTimeout(() => {
            copyBtn.innerHTML = '<span class="material-icons">content_copy</span>';
          }, 2000);
        } catch (err) {
          console.error('Failed to copy:', err);
          showToast('Failed to copy code');
        }
      });
    }

    document.addEventListener('DOMContentLoaded', async () => {
      try {
        // Load Chart.js first
        await loadScript('https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js');

        // Then load the datalabels plugin
        await loadScript('https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0');

        // Now wait a moment to ensure proper initialization
        await new Promise(resolve => setTimeout(resolve, 100));

        if (window.Chart && window.ChartDataLabels) {
          // Register the plugin
          Chart.register(ChartDataLabels);

          // Set default Chart.js options
          Chart.defaults.font.family = 'sans-serif';
          Chart.defaults.color = '#94a3b8';
          Chart.defaults.elements.line.borderJoinStyle = 'round';
          Chart.defaults.elements.bar.borderRadius = 4;

          await initializeCharts();
          setupInsights();
        } else {
          console.error('Chart.js or ChartDataLabels not properly loaded');
        }
      } catch (err) {
        console.error('Error initializing charts:', err);
      }
    });


    // Handle window resizing
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        if (window.chartInstances) {
          Object.values(window.chartInstances).forEach(chart => {
            if (chart && typeof chart.resize === 'function') {
              chart.resize();
            }
          });
        }
      }, 250);
    });

    // Helper function to load scripts
    function loadScript(src) {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.onload = resolve;
        script.onerror = reject;
        document.head.appendChild(script);
      });
    }



    // Update preview and code
    async function updatePreviewAndCode() {
      if (!state.currentSongId) return;

      const dimensions = {
        small: { width: 320, height: 160 },
        normal: { width: 400, height: 200 },
        large: { width: 500, height: 240 }
      };

      const { width, height } = dimensions[integrationState.size];

      // Update preview iframe
      const previewFrame = document.getElementById('previewFrame');
      previewFrame.style.width = `${width}px`;
      previewFrame.style.height = `${height}px`;

      const embedUrl = `${integrationState.serverDomain}/embed/${state.currentSongId}?size=${integrationState.size}&theme=${integrationState.theme}`;
      previewFrame.src = embedUrl;

      // Generate embed code
      const embedCode = `<iframe
  src="${embedUrl}"
  width="${width}"
  height="${height}"
  frameborder="0"
  allowtransparency="true"
  allow="encrypted-media"
  loading="lazy">
</iframe>`;

      document.getElementById('embedCode').textContent = embedCode;
    }

    // Initialize integration features
    initializeIntegration();

    // Update preview when song changes
    const originalLoadAndPlay = window.loadAndPlay;
    window.loadAndPlay = async function (songId) {
      await originalLoadAndPlay(songId);
      if (document.getElementById('integrationContainer').style.display === 'block') {
        updatePreviewAndCode();
      }
    };


  </script>
  <script>
    // Enhanced insights visualization with Chart.js

    // Utility for generating gradients
    function createGradient(ctx, colorStart, colorEnd) {
      const gradient = ctx.createLinearGradient(0, 0, 0, 300);
      gradient.addColorStop(0, colorStart);
      gradient.addColorStop(1, colorEnd);
      return gradient;
    }




    // Enhanced initialization with chart responsiveness
    document.addEventListener('DOMContentLoaded', () => {
      // Load Chart.js with animation plugin
      Promise.all([
        loadScript('https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js'),
        loadScript('https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0')
      ]).then(() => {
        // Register Chart.js plugins
        Chart.register(ChartDataLabels);

        // Set default Chart.js options for all charts
        Chart.defaults.font.family = 'sans-serif';
        Chart.defaults.color = '#94a3b8';
        Chart.defaults.elements.line.borderJoinStyle = 'round';
        Chart.defaults.elements.bar.borderRadius = 4;
      }).catch(err => {
        console.error('Error loading chart libraries:', err);
        // showToast('Failed to load visualization libraries');
      });
    });
    // Add insights button to controls
    const insightsButton = document.createElement('button');
    insightsButton.className = 'control-button';
    insightsButton.innerHTML = '<span class="material-icons">insights</span>';
    insightsButton.title = 'View Insights';
    document.querySelector('.player-controls').appendChild(insightsButton);

    // Insights modal handling
    const insightsModal = document.getElementById('insightsModal');
    const closeInsights = document.getElementById('closeInsights');

    insightsButton.addEventListener('click', () => {
      insightsModal.style.display = 'block';
      loadInsights();
    });

    closeInsights.addEventListener('click', () => {
      insightsModal.style.display = 'none';
    });
    // Format duration for insights
    function formatInsightDuration(seconds) {
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const days = Math.floor(hours / 24);

      if (days > 0) {
        return `${days}d ${hours % 24}h`;
      } else if (hours > 0) {
        return `${hours}h ${minutes}m`;
      }
      return `${minutes}m`;
    }

    // Helper function to update recent activity
    function updateRecentActivity(activities) {
      const recentActivityList = document.getElementById('recentActivityList');
      recentActivityList.innerHTML = activities.map((activity, index) => `
    <div class="activity-item fade-in" style="animation-delay: ${index * 0.05}s">
      <div class="activity-time">${formatRelativeTime(new Date(activity.started_at))}</div>
      <div class="activity-info">
        <div class="activity-title">${activity.title}</div>
        <div class="activity-artist">${activity.artist}</div>
      </div>
      <div class="activity-completion">
        <div class="completion-bar" style="width: ${activity.completion}%"></div>
      </div>
    </div>
  `).join('');
    }

    // Initialize global chart instances object
    window.chartInstances = {
      daily: null,
      hourly: null,
      completion: null
    };
    const TimeUtils = {
      /**
       * Format time with IST timezone
       * @param {Date|string} date - Date to format
       * @param {boolean} includeDate - Whether to include date in output
       * @returns {string} Formatted time string
       */
      formatTime(date, includeDate = false) {
        if (!date) return '->';

        try {
          const d = new Date(date);
          // Convert to IST
          const istTime = new Date(d.getTime() + (5.5 * 60 * 60 * 1000));

          const options = {
            hour: 'numeric',
            minute: 'numeric',
            hour12: true,
            timeZone: 'Asia/Kolkata'
          };

          if (includeDate) {
            options.day = 'numeric';
            options.month = 'short';
            options.year = 'numeric';
          }

          return istTime.toLocaleString('en-IN', options) + ' IST';
        } catch (e) {
          console.error('Time formatting error:', e);
          return '->';
        }
      },

      /**
       * Format relative time in IST
       * @param {Date|string} date - Date to format
       * @returns {string} Relative time string
       */
      formatRelativeTime(date) {
        if (!date) return 'Unknown time';

        try {
          const now = new Date();
          const then = new Date(date);

          // Convert both to IST
          const istNow = new Date(now.getTime() + (5.5 * 60 * 60 * 1000));
          const istThen = new Date(then.getTime() + (5.5 * 60 * 60 * 1000));

          const diff = istNow - istThen;
          const seconds = Math.floor(diff / 1000);

          if (seconds < 60) return 'just now';
          if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
          if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
          if (seconds < 604800) return `${Math.floor(seconds / 86400)}d ago`;

          return this.formatTime(date, true);
        } catch (e) {
          console.error('Relative time error:', e);
          return 'Unknown time';
        }
      },

      /**
       * Get current IST time
       * @returns {Date} Current time in IST
       */
      getCurrentIST() {
        const now = new Date();
        return new Date(now.getTime() + (5.5 * 60 * 60 * 1000));
      },

      /**
       * Convert UTC to IST
       * @param {Date|string} date - UTC date to convert
       * @returns {Date} IST date
       */
      utcToIST(date) {
        if (!date) return null;
        const d = new Date(date);
        return new Date(d.getTime() + (5.5 * 60 * 60 * 1000));
      }
    };

    // Modified createDailyChart function
    function createDailyChart(dailyData) {
      try {
        const canvas = document.getElementById('dailyPatternChartCanvas');
        if (!canvas) {
          console.error('Daily chart canvas not found');
          return;
        }

        const ctx = canvas.getContext('2d');
        if (!ctx) {
          console.error('Could not get daily chart context');
          return;
        }

        // Clean up existing chart
        if (window.chartInstances.daily) {
          window.chartInstances.daily.destroy();
        }

        const gradient = ctx.createLinearGradient(0, 0, 0, 300);
        gradient.addColorStop(0, 'rgba(79,70,229,0.4)');
        gradient.addColorStop(1, 'rgba(79,70,229,0.1)');

        const labels = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
        const data = labels.map((_, i) => dailyData[i] || 0);

        window.chartInstances.daily = new Chart(ctx, {
          type: 'bar',
          data: {
            labels,
            datasets: [{
              data,
              backgroundColor: gradient,
              borderColor: 'rgba(79,70,229,0.8)',
              borderWidth: 2,
              borderRadius: 6,
              barThickness: 'flex',
              maxBarThickness: 25
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false },
              tooltip: {
                mode: 'index',
                intersect: false,
                callbacks: {
                  label: (context) => `${context.parsed.y} plays`
                },
                backgroundColor: 'rgba(15,23,42,0.9)',
                titleColor: '#f8fafc',
                bodyColor: '#94a3b8',
                borderColor: 'rgba(148,163,184,0.1)',
                borderWidth: 1,
                padding: 10,
                displayColors: false
              }
            },
            scales: {
              x: { grid: { display: false }, ticks: { color: '#94a3b8' } },
              y: {
                beginAtZero: true,
                grid: { color: 'rgba(148,163,184,0.1)', drawBorder: false },
                ticks: {
                  color: '#94a3b8',
                  callback: (value) => value % 1 === 0 ? value : ''
                }
              }
            }
          }
        });
      } catch (error) {
        console.error('Error creating daily chart:', error);
      }
    }

    // Modified createHourlyChart function
    function createHourlyChart(hourlyData) {
      try {
        const canvas = document.getElementById('hourlyPatternChartCanvas');
        if (!canvas) {
          console.error('Hourly chart canvas not found');
          return;
        }

        const ctx = canvas.getContext('2d');
        if (!ctx) {
          console.error('Could not get hourly chart context');
          return;
        }

        // Clean up existing chart
        if (window.chartInstances.hourly) {
          window.chartInstances.hourly.destroy();
        }

        const gradient = ctx.createLinearGradient(0, 0, 0, 300);
        gradient.addColorStop(0, 'rgba(129,140,248,0.4)');
        gradient.addColorStop(1, 'rgba(129,140,248,0.1)');

        const labels = Array.from({ length: 24 }, (_, i) =>
          `${i.toString().padStart(2, '0')}:00`);
        const data = labels.map((_, i) => hourlyData[i] || 0);

        window.chartInstances.hourly = new Chart(ctx, {
          type: 'line',
          data: {
            labels,
            datasets: [{
              data,
              backgroundColor: gradient,
              borderColor: 'rgba(129,140,248,0.8)',
              borderWidth: 2,
              tension: 0.4,
              fill: true
            }]
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: false }
            },
            scales: {
              x: {
                grid: { display: false },
                ticks: {
                  color: '#94a3b8',
                  maxRotation: 45,
                  minRotation: 45,
                  callback: (_, index) => index % 3 === 0 ? labels[index] : ''
                }
              },
              y: {
                beginAtZero: true,
                grid: {
                  color: 'rgba(148,163,184,0.1)',
                  drawBorder: false
                }
              }
            }
          }
        });
      } catch (error) {
        console.error('Error creating hourly chart:', error);
      }
    }
    // Modified createPatternCharts function
    function createPatternCharts(patterns) {
      try {
        createDailyChart(patterns.daily);
        createHourlyChart(patterns.hourly);
      } catch (error) {
        console.error('Error creating pattern charts:', error);
      }
    }
    async function loadInsights() {
      try {
        const response = await fetch('/api/insights');
        const data = await response.json();

        // Helper function to safely update element text
        const setElementText = (id, value) => {
          const element = document.getElementById(id);
          if (element) element.textContent = value;
        };

        // Update basic stats (assuming previous fix for keys is applied)
        setElementText('totalListeningTime', formatInsightDuration(data.overview.total_time));
        setElementText('totalSongs', data.overview.total_songs.toLocaleString());
        setElementText('uniqueArtists', data.overview.unique_artists.toLocaleString());
        setElementText('averageDaily', Math.round(data.overview.average_daily).toString());

        // Update top artists list
        const topArtistsList = document.getElementById('topArtistsList');
        if (topArtistsList && data.top_artists) {
          topArtistsList.innerHTML = data.top_artists.map((artist, index) => `
        <div class="artist-card fade-in" style="animation-delay: ${index * 0.1}s">
          <div class="artist-rank">#${index + 1}</div>
          <div class="artist-info">
            <div class="artist-name">${artist.name}</div>
            <div class="artist-stats">
              ${artist.plays.toLocaleString()} plays â€¢ ${formatInsightDuration(artist.time)}
            </div>
          </div>
        </div>
      `).join('');
        }

        // Initialize charts (ensure this is working as expected)
        if (!window.Chart) {
          await loadScript('https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.0/chart.min.js');
        }
        await initializeCharts(); // Ensure charts are initialized before creating pattern charts
        if (data.listening_patterns) {
          createPatternCharts(data.listening_patterns);
        }

        // Update recent activity
        if (data.recent_activity) {
          const recentActivityList = document.getElementById('recentActivityList');
          if (recentActivityList) {
            recentActivityList.innerHTML = data.recent_activity.map((activity, index) => `
          <div class="activity-item fade-in" style="animation-delay: ${index * 0.05}s">
            <div class="activity-time">${TimeUtils.formatRelativeTime(new Date(activity.started_at_iso))}</div>
            <div class="activity-info">
              <div class="activity-title">${activity.title}</div>
              <div class="activity-artist">${activity.artist}</div>
            </div>
            <div class="activity-completion">
              <div class="completion-bar" style="width: ${activity.completion_percentage}%"></div>
            </div>
          </div>
        `).join('');
          }
        }

        // Update completion rate
        if (data.completion_rates?.average_completion_percentage) { // Check the correct key based on util.py
          // Ensure there's an element with id 'averageCompletion' or similar if you want to display this
          setElementText('averageCompletion', `${data.completion_rates.average_completion_percentage.toFixed(1)}%`);
        }

      } catch (error) {
        console.error('Error loading insights:', error);
        showToast('Failed to load insights');
      }
    }
    function updateInsightElements(data) {
      // Helper function to safely update element text
      const setElementText = (id, value) => {
        const element = document.getElementById(id);
        if (element) element.textContent = value;
      };

      // Helper for creating artist cards
      const createArtistCard = (artist, index) => `
    <div class="artist-card fade-in" style="animation-delay: ${index * 0.1}s">
      <div class="artist-rank">#${index + 1}</div>
      <div class="artist-info">
        <div class="artist-name">${artist.name}</div>
        <div class="artist-stats">
          ${artist.plays.toLocaleString()} plays â€¢ ${formatInsightDuration(artist.time)}
        </div>
      </div>
    </div>
  `;

      // Helper for creating activity items
      const createActivityItem = (activity, index) => `
    <div class="activity-item fade-in" style="animation-delay: ${index * 0.05}s">
      <div class="activity-time">${formatRelativeTime(new Date(activity.started_at))}</div>
      <div class="activity-info">
        <div class="activity-title">${activity.title}</div>
        <div class="activity-artist">${activity.artist}</div>
      </div>
      <div class="activity-completion">
        <div class="completion-bar" style="width: ${activity.completion}%"></div>
      </div>
    </div>
  `;

      // Update overview stats
      setElementText('totalListeningTime', formatInsightDuration(data.overview.total_time));
      setElementText('totalSongs', data.overview.total_songs.toLocaleString());
      setElementText('uniqueArtists', data.overview.unique_artists.toLocaleString());
      setElementText('averageDaily', Math.round(data.overview.average_daily).toString());

      // Update top artists
      const topArtistsList = document.getElementById('topArtistsList');
      if (topArtistsList && data.top_artists) {
        topArtistsList.innerHTML = data.top_artists.map(createArtistCard).join('');
      }

      // Update recent activity
      const recentActivityList = document.getElementById('recentActivityList');
      if (recentActivityList && data.recent_activity) {
        recentActivityList.innerHTML = data.recent_activity.map(createActivityItem).join('');
      }

      // Update completion rate
      if (data.completion_rates?.average_completion) {
        setElementText('averageCompletion', `${data.completion_rates.average_completion.toFixed(1)}%`);
      }
    }
    function createActivityItem(activity, index) {
      const activityDate = new Date(activity.started_at);
      const formattedTime = formatRelativeTime(activityDate);

      return `
    <div class="activity-item fade-in" style="animation-delay: ${index * 0.05}s">
      <div class="activity-time">${formattedTime}</div>
      <div class="activity-info">
        <div class="activity-title">${activity.title}</div>
        <div class="activity-artist">${activity.artist}</div>
      </div>
      <div class="activity-completion">
        <div class="completion-bar" style="width: ${activity.completion}%"></div>
      </div>
    </div>
  `;
    }

    let currentListenId = null;
    let currentSessionId = null;

    async function startListeningSession(songId, title, artist) {
      try {
        const response = await fetch('/api/listen/start', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ songId, title, artist })
        });
        const data = await response.json();
        currentListenId = data.listenId;
        currentSessionId = data.sessionId;
      } catch (error) {
        console.error('Failed to start listening session:', error);
      }
    }

    async function endListeningSession(duration, listenedDuration) {
      if (!currentListenId) {
        // console.log("endListeningSession called but no currentListenId, returning.");
        return;
      }

      const listenIdToProcess = currentListenId; // Capture it before nulling
      currentListenId = null; // Optimistically nullify to prevent duplicate calls for the same session segment

      try {
        console.log(`Ending session for listenId: ${listenIdToProcess}, duration: ${duration}, listened: ${listenedDuration}`);
        if (listenedDuration === undefined || isNaN(listenedDuration)) {
          console.warn(`endListeningSession: listenedDuration is invalid (${listenedDuration}), sending 0.`);
          listenedDuration = 0;
        }
        if (duration === undefined || isNaN(duration)) {
          console.warn(`endListeningSession: duration is invalid (${duration}), sending 0.`);
          duration = 0;
        }

        const response = await fetch('/api/listen/end', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            listenId: listenIdToProcess,
            duration: Math.max(0, duration), // Ensure non-negative
            listenedDuration: Math.max(0, listenedDuration) // Ensure non-negative
          })
        });
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({ detail: "Failed to parse error response from /api/listen/end" }));
          console.error('Failed to end listening session on server:', response.status, errorData);
          // If server fails, potentially reinstate currentListenId if this session segment was critical
          // and no other end mechanism (like periodic update) exists. For now, it remains null.
        } else {
          console.log("Successfully ended listening session for listenId:", listenIdToProcess);
        }
      } catch (error) {
        console.error('Error in endListeningSession fetch:', error);
      }
      // currentListenId is already nulled at the start of this logical block for this session.
    }
  </script>
  <script>
    if ('mediaSession' in navigator) {
      navigator.mediaSession.metadata = new MediaMetadata({
        title: '',
        artist: '',
        artwork: []
      });

      navigator.mediaSession.setActionHandler('play', () => {
        togglePlay();
      });
      navigator.mediaSession.setActionHandler('pause', () => {
        togglePlay();
      });
      navigator.mediaSession.setActionHandler('previoustrack', () => {
        playPrevious();
      });
      navigator.mediaSession.setActionHandler('nexttrack', () => {
        playNext();
      });
    }
    // Add history button to controls
    const historyButton = document.createElement('button');
    historyButton.className = 'control-button';
    historyButton.innerHTML = '<span class="material-icons">history</span>';
    historyButton.title = 'View History';
    document.querySelector('.player-controls').appendChild(historyButton);

    const historyModal = document.getElementById('historyModal');
    const closeHistory = document.getElementById('closeHistory');
    const historyList = document.getElementById('historyList');

    historyButton.addEventListener('click', () => {
      historyModal.style.display = 'block';
      loadHistory();
    });

    closeHistory.addEventListener('click', () => {
      historyModal.style.display = 'none';
    });
    class ImageLoader {
      constructor() {
        this.cache = new Map();
        this.corsEnabled = new Set();  // Track which domains support CORS
      }

      async loadImage(url, retryWithNoCors = true) {
        if (this.cache.has(url)) {
          return this.cache.get(url);
        }

        // For YouTube thumbnails, modify URL to use img.youtube.com
        if (url.includes('i.ytimg.com')) {
          url = url.replace('i.ytimg.com', 'img.youtube.com');
        }

        try {
          const imgUrl = await this.loadWithFallback(url, retryWithNoCors);
          this.cache.set(url, imgUrl);
          return imgUrl;
        } catch (error) {
          console.warn(`Failed to load image: ${url}`, error);
          return '/static/images/default-cover.png';
        }
      }

      async loadWithFallback(url, retryWithNoCors) {
        // Try loading with proxy first for known non-CORS domains
        if (!this.corsEnabled.has(new URL(url).hostname)) {
          try {
            const proxyUrl = `/api/proxy/image?url=${encodeURIComponent(url)}`;
            const response = await fetch(proxyUrl);
            if (response.ok) {
              const blob = await response.blob();
              return URL.createObjectURL(blob);
            }
          } catch (error) {
            console.warn('Proxy fetch failed, trying direct:', error);
          }
        }

        // Try direct load with CORS
        try {
          const response = await fetch(url, { mode: 'cors' });
          if (response.ok) {
            this.corsEnabled.add(new URL(url).hostname);
            const blob = await response.blob();
            return URL.createObjectURL(blob);
          }
        } catch (error) {
          console.warn('CORS fetch failed:', error);
        }

        // Last resort: return original URL for <img> to handle
        if (retryWithNoCors) {
          return url;
        }

        throw new Error('All image loading attempts failed');
      }
    }

    // Create a single instance for use throughout the app
    const imageLoader = new ImageLoader();
    // Update the ImageCache class with better CORS handling
    class ImageCache {
      constructor() {
        this.cache = new Map();
        this.retryCount = new Map();
        this.maxRetries = 4;
        this.initLocalStorage();
      }

      async loadImage(url, fallbackUrl = '/static/images/default-cover.png') {
        try {
          // First try memory cache
          if (this.cache.has(url)) {
            return this.cache.get(url);
          }

          // Then check localStorage cache
          const cacheData = JSON.parse(localStorage.getItem('imageCacheData') || '{}');
          if (cacheData[url] && Date.now() - cacheData[url].timestamp < 24 * 60 * 60 * 1000) {
            return cacheData[url].dataUrl;
          }

          // Try loading with CORS mode first
          const img = new Image();
          img.crossOrigin = 'anonymous';
          img.src = url;

          const imageData = await new Promise((resolve, reject) => {
            img.onload = () => {
              const canvas = document.createElement('canvas');
              canvas.width = img.width;
              canvas.height = img.height;
              const ctx = canvas.getContext('2d');
              ctx.drawImage(img, 0, 0);
              resolve(canvas.toDataURL('image/jpeg'));
            };
            img.onerror = () => reject(new Error('Image load failed'));
          });

          // Cache the successful result
          this.cache.set(url, imageData);
          cacheData[url] = {
            dataUrl: imageData,
            timestamp: Date.now()
          };
          localStorage.setItem('imageCacheData', JSON.stringify(cacheData));

          return imageData;

        } catch (error) {
          // If first attempt fails, try without CORS
          try {
            const response = await fetch(url, {
              mode: 'no-cors',
              cache: 'force-cache'
            });
            return url; // Return original URL if no-cors succeeds
          } catch (e) {
            console.warn(`Image load error for ${url}:`, e);
            return fallbackUrl;
          }
        }
      }

      initLocalStorage() {
        if (!localStorage.getItem('imageCacheData')) {
          localStorage.setItem('imageCacheData', JSON.stringify({}));
        }
        this.clearOldCache();
      }

      clearOldCache() {
        const cacheData = JSON.parse(localStorage.getItem('imageCacheData') || '{}');
        const now = Date.now();
        const oneDay = 24 * 60 * 60 * 1000;

        Object.keys(cacheData).forEach(key => {
          if (now - cacheData[key].timestamp > oneDay) {
            delete cacheData[key];
          }
        });

        localStorage.setItem('imageCacheData', JSON.stringify(cacheData));
      }

      blobToDataUrl(blob) {
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = reject;
          reader.readAsDataURL(blob);
        });
      }
    }
    let offset = 0;
    const limit = 5; // Load 5 items per scroll
    let isLoading = false;
    let observer = null; // Store observer to manage it properly

    //   async function loadHistory() {
    //     const historyList = document.getElementById('historyList');
    //     if (!historyList) return;

    //     // Clear any existing observer to prevent duplicate observers
    //     if (observer) {
    //       observer.disconnect();
    //     }

    //     // Reset offset and clear the list explicitly
    //     offset = 0;
    //     historyList.innerHTML = Array(5).fill(0).map(() => `
    //   <div class="history-item skeleton">
    //     <div class="history-thumbnail skeleton"></div>
    //     <div class="history-info skeleton"></div>
    //   </div>
    // `).join('');

    //     await loadMoreHistory();

    //     // Set up event delegation (only once)
    //     if (!historyList.dataset.listenerAdded) {
    //       historyList.addEventListener('click', (event) => {
    //         const historyItem = event.target.closest('.history-item');
    //         if (historyItem) {
    //           const songId = historyItem.dataset.id;
    //           loadAndPlay(songId);
    //           document.getElementById('historyModal').style.display = 'none';
    //         }
    //       });
    //       historyList.dataset.listenerAdded = 'true';
    //     }

    //     // Set up infinite scrolling
    //     const sentinel = document.createElement('div');
    //     sentinel.id = 'sentinel';
    //     historyList.appendChild(sentinel);

    //     observer = new IntersectionObserver(
    //       (entries) => {
    //         if (entries[0].isIntersecting && !isLoading) {
    //           loadMoreHistory();
    //         }
    //       },
    //       { rootMargin: '100px' }
    //     );
    //     observer.observe(sentinel);
    //   }


    // History loading state
    let historyOffset = 0;
    const historyLimit = 5; // Load 5 items per request
    let isHistoryLoading = false;
    let historyHasMore = true;
    let historyObserver = null;

    async function loadHistory() {
      const historyModal = document.getElementById('historyModal');
      const historyList = document.getElementById('historyList');
      if (!historyList) return;

      // Reset state
      historyOffset = 0;
      historyHasMore = true;
      historyList.innerHTML = '';

      // Show modal and initial skeletons
      historyModal.style.display = 'block';
      showHistorySkeletons(historyList);

      await loadMoreHistory(true);

      // Event delegation for play buttons, ensuring the listener is only added once.
      if (!historyList.dataset.listenerAttached) {
        historyList.addEventListener('click', (event) => {
          const historyItem = event.target.closest('.history-item');
          const playButton = event.target.closest('.history-play');
          if (historyItem && playButton) {
            const songId = historyItem.dataset.id;
            if (songId) {
              loadAndPlay(songId);
              historyModal.style.display = 'none';
            }
          }
        });
        historyList.dataset.listenerAttached = 'true';
      }

      // Setup Intersection Observer for infinite scroll
      setupHistoryObserver(historyList);
    }
    async function loadMoreHistory(initialLoad = false) {
      if (isHistoryLoading || !historyHasMore) return;
      isHistoryLoading = true;

      const historyList = document.getElementById('historyList');
      try {
        const response = await fetch(`/api/queue?limit=${historyLimit}&offset=${historyOffset}`);
        if (!response.ok) throw new Error('Failed to fetch history');
        const history = await response.json();

        if (initialLoad) {
          historyList.innerHTML = '';
        }

        if (history.length === 0) {
          historyHasMore = false;
          if (historyOffset === 0) {
            historyList.innerHTML = '<p>No history available</p>';
          }
          return;
        }

        const fragment = document.createDocumentFragment();
        history.forEach((item) => {
          const playedTime = TimeUtils.formatTime(item.played_at, true);
          const div = document.createElement('div');
          div.className = 'history-item';
          div.dataset.id = item.id;
          div.innerHTML = `
        <img class="history-thumbnail"
             src="${item.thumbnail || '/static/images/default-cover.png'}"
             alt="${item.title || 'Unknown Title'}"
             loading="lazy"
             onerror="this.src='/static/images/default-cover.png';">
        <div class="history-info">
          <div class="history-title">${item.title || 'Unknown Title'}</div>
          <div class="history-artist">${item.artist || 'Unknown Artist'}</div>
          <div class="history-time">${playedTime}</div>
        </div>
        <div class="history-play">
          <span class="material-icons">play_arrow</span>
        </div>
      `;
          fragment.appendChild(div);
        });

        historyList.appendChild(fragment);

        // Move the sentinel to the end after adding new items
        const sentinel = document.getElementById('history-sentinel');
        if (sentinel) {
          historyList.appendChild(sentinel);
        }

        historyOffset += history.length;
        historyHasMore = history.length === historyLimit;

      } catch (error) {
        console.error('Error loading history:', error);
        if (historyOffset === 0) {
          historyList.innerHTML = '<p>Failed to load history</p>';
        }
      } finally {
        isHistoryLoading = false;
      }
    }
    function showHistorySkeletons(container) {
      const fragment = document.createDocumentFragment();
      for (let i = 0; i < historyLimit; i++) {
        const div = document.createElement('div');
        div.className = 'history-item skeleton';
        div.innerHTML = `
      <div class="history-thumbnail skeleton"></div>
      <div class="history-info skeleton">
        <div class="history-title skeleton-loading" style="width: 70%; height: 16px;"></div>
        <div class="history-artist skeleton-loading" style="width: 50%; height: 14px; margin-top: 8px;"></div>
        <div class="history-time skeleton-loading" style="width: 30%; height: 12px; margin-top: 8px;"></div>
      </div>
      <div class="history-play skeleton-loading" style="width: 40px; height: 40px; border-radius: 50%;"></div>
    `;
        fragment.appendChild(div);
      }
      container.appendChild(fragment);
    }

    function setupHistoryObserver(historyList) {
      if (historyObserver) {
        historyObserver.disconnect();
      }

      const sentinel = document.createElement('div');
      sentinel.id = 'history-sentinel';
      historyList.appendChild(sentinel);

      historyObserver = new IntersectionObserver(
        (entries) => {
          if (entries[0].isIntersecting && !isHistoryLoading && historyHasMore) {
            loadMoreHistory();
          }
        },
        { rootMargin: '100px' }
      );
      historyObserver.observe(sentinel);
    }


    window.loadAndPlay = async function (songId) {
      await originalLoadAndPlay(songId);
      if (document.getElementById('historyModal').style.display === 'block') {
        loadHistory();
      }
    };

    const historyStyles = `
.history-error {
    text-align: center;
    padding: 2rem;
    color: var(--text-secondary);
}

.history-error .material-icons {
    font-size: 3rem;
    margin-bottom: 1rem;
    color: var(--error-color);
}

.history-item {
    display: flex;
    align-items: center;
    padding: 1rem;
    border-radius: 12px;
    margin-bottom: 1rem;
    background: var(--surface-color);
    transition: all 0.3s ease;
    cursor: pointer;
}

.history-item:hover {
    background: var(--card-color);
    transform: translateY(-2px);
}

.history-thumbnail {
    width: 60px;
    height: 60px;
    border-radius: 8px;
    margin-right: 1rem;
    object-fit: cover;
    background-color: var(--card-color);
}

.history-play {
    width: 40px;
    height: 40px;
    border-radius: 50%;
    background: var(--accent-gradient);
    display: flex;
    align-items: center;
    justify-content: center;
    margin-left: 1rem;
    opacity: 0;
    transition: all 0.3s ease;
}

.history-time {
    color: var(--text-secondary);
    font-size: 0.8rem;
    margin-top: 0.25rem;
}
`;

    // Add styles to document
    const styleSheet = document.createElement('style');
    styleSheet.textContent = historyStyles;
    document.head.appendChild(styleSheet);
    // Update chart initialization

    // Update createPatternCharts function with better error handling
    function createPatternCharts(patterns) {
      if (!patterns) return;

      const dailyCanvas = document.getElementById('dailyPatternChartCanvas');
      const hourlyCanvas = document.getElementById('hourlyPatternChartCanvas');

      if (dailyCanvas && patterns.daily) {
        createDailyChart(patterns.daily);
      }
      if (hourlyCanvas && patterns.hourly) {
        createHourlyChart(patterns.hourly);
      }
    }
    function createActivityItem(activity, index) {
      const timestamp = TimeUtils.formatRelativeTime(activity.started_at);

      return `
    <div class="activity-item fade-in" style="animation-delay: ${index * 0.05}s">
      <div class="activity-time">${timestamp}</div>
      <div class="activity-info">
        <div class="activity-title">${activity.title}</div>
        <div class="activity-artist">${activity.artist}</div>
      </div>
      <div class="activity-completion">
        <div class="completion-bar" style="width: ${activity.completion}%"></div>
      </div>
    </div>
  `;
    }


    // Time formatting utilities
    const TimeFormatter = {
      /**
       * Format seconds to MM:SS or HH:MM:SS
       * @param {number} seconds - Time in seconds
       * @returns {string} Formatted time string
       */
      formatTime(seconds) {
        if (!seconds || isNaN(seconds)) {
          seconds = 0;
        }

        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);

        if (hours > 0) {
          return `${hours}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }
        return `${minutes}:${String(secs).padStart(2, '0')}`;
      },

      /**
       * Format time with IST timezone
       * @param {Date|string} date - Date to format
       * @param {boolean} includeDate - Whether to include date in output
       * @returns {string} Formatted time string
       */
      formatDateTime(dateInput, includeDatePart = true, targetTimeZone = undefined) {
        if (!dateInput) return '->';
        try {
          const dateObj = (typeof dateInput === 'string') ? new Date(dateInput) : dateInput;
          if (isNaN(dateObj.getTime())) return 'Invalid Date';

          const options = {
            hour: 'numeric',
            minute: 'numeric',
            hour12: true,
          };
          if (targetTimeZone) {
            options.timeZone = targetTimeZone;
          }

          if (includeDatePart) {
            options.day = 'numeric';
            options.month = 'short';
            // Only add year if it's not the current year, or if it's a full date request
            if (dateObj.getFullYear() !== new Date().getFullYear() || targetTimeZone) {
              options.year = 'numeric';
            }
          }

          let formattedString = dateObj.toLocaleString('en-IN', options);
          if (targetTimeZone === 'Asia/Kolkata') {
            formattedString += ' IST';
          }
          return formattedString;

        } catch (e) {
          console.error('Time formatting error:', e, 'Input:', dateInput);
          return '->';
        }
      },

      /**
       * Format relative time in IST
       * @param {Date|string} date - Date to format
       * @returns {string} Relative time string
       */
      formatRelativeTime(dateInput) {
        if (!dateInput) return 'Unknown time';
        try {
          const dateObj = (typeof dateInput === 'string') ? new Date(dateInput) : dateInput;
          if (isNaN(dateObj.getTime())) return 'Invalid Date';

          const now = new Date(); // User's browser current local time
          const diffSeconds = Math.floor((now.getTime() - dateObj.getTime()) / 1000);

          if (diffSeconds < 5) return 'just now';
          if (diffSeconds < 60) return `${diffSeconds}s ago`;

          const diffMinutes = Math.floor(diffSeconds / 60);
          if (diffMinutes < 60) return `${diffMinutes}m ago`;

          const diffHours = Math.floor(diffMinutes / 60);
          if (diffHours < 24) return `${diffHours}h ago`;

          const diffDays = Math.floor(diffHours / 24);
          if (diffDays < 7) return `${diffDays}d ago`;

          // Fallback to absolute time in IST for older dates (like history)
          return this.formatDateTime(dateObj, true, 'Asia/Kolkata');
        } catch (e) {
          console.error('Relative time error:', e, 'Input:', dateInput);
          return 'Unknown time';
        }
      },

      /**
       * Format duration for insights
       * @param {number} seconds - Duration in seconds
       * @returns {string} Formatted duration string
       */
      formatDuration(totalSeconds) {
        if (isNaN(totalSeconds) || totalSeconds === undefined || totalSeconds === null) {
          return '0m'; // Default for invalid input
        }
        totalSeconds = Number(totalSeconds);
        if (totalSeconds < 0) totalSeconds = 0;

        const days = Math.floor(totalSeconds / (3600 * 24));
        const hours = Math.floor((totalSeconds % (3600 * 24)) / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        // const seconds = Math.floor(totalSeconds % 60); // If you need seconds part

        if (days > 0) return `${days}d ${hours}h`;
        if (hours > 0) return `${hours}h ${minutes}m`;
        return `${minutes}m`;
      }
    };

    // Make formatTime available globally
    window.formatTime = TimeFormatter.formatTime;
    window.formatDateTime = TimeFormatter.formatDateTime;
    window.formatRelativeTime = TimeFormatter.formatRelativeTime;
    window.formatDuration = TimeFormatter.formatDuration;
  </script>
  <script>
    // Add hover effect to music notes
    document.querySelectorAll('.music-note').forEach(note => {
      setInterval(() => {
        note.style.left = Math.random() * 80 + 10 + '%';
      }, 3000);
    });
  </script>
  <script>
    // Create a notification manager class
    class NotificationManager {
      constructor() {
        this.init();
      }

      init() {
        // Create container for notifications
        const container = document.createElement('div');
        container.className = 'notification-container';
        document.body.appendChild(container);

        // Add styles
        const styles = document.createElement('style');
        styles.textContent = `
      .notification-container {
        position: fixed;
        top: 20px;
        left: 20px;
        z-index: 9999;
        display: flex;
        flex-direction: column;
        gap: 10px;
        max-width: 320px;
      }

      .notification {
        background: var(--surface-color);
        border-left: 4px solid;
        border-radius: 8px;
        padding: 16px;
        color: var(--text-primary);
        display: flex;
        align-items: flex-start;
        gap: 12px;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        transform-origin: left;
        animation: slideIn 0.3s ease forwards;
        cursor: pointer;
        position: relative;
        overflow: hidden;
        transition: all 0.3s ease;
      }

      .notification.removing {
        animation: slideOut 0.3s ease forwards;
      }

      .notification:hover {
        transform: translateX(5px);
      }

      .notification-icon {
        font-size: 20px;
        flex-shrink: 0;
      }

      .notification-content {
        flex-grow: 1;
        padding-right: 20px;
      }

      .notification-title {
        font-weight: 600;
        margin-bottom: 4px;
      }

      .notification-message {
        font-size: 0.9rem;
        opacity: 0.9;
      }

      .notification-close {
        position: absolute;
        top: 8px;
        right: 8px;
        padding: 4px;
        border-radius: 50%;
        cursor: pointer;
        opacity: 0.6;
        transition: all 0.2s;
        background: none;
        border: none;
        color: inherit;
      }

      .notification-close:hover {
        opacity: 1;
        background: rgba(255,255,255,0.1);
      }

      .notification-progress {
        position: absolute;
        bottom: 0;
        left: 0;
        width: 100%;
        height: 3px;
        background: rgba(255,255,255,0.1);
      }

      .notification-progress-bar {
        height: 100%;
        background: currentColor;
        transition: width linear;
      }

      /* Types */
      .notification.success {
        background: rgba(34,197,94,0.1);
        border-color: #22c55e;
        color: #22c55e;
      }

      .notification.error {
        background: rgba(239,68,68,0.1);
        border-color: #ef4444;
        color: #ef4444;
      }

      .notification.warning {
        background: rgba(234,179,8,0.1);
        border-color: #eab308;
        color: #eab308;
      }

      .notification.info {
        background: rgba(59,130,246,0.1);
        border-color: #3b82f6;
        color: #3b82f6;
      }

      @keyframes slideIn {
        from {
          transform: translateX(-100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      @keyframes slideOut {
        from {
          transform: translateX(0);
          opacity: 1;
        }
        to {
          transform: translateX(-100%);
          opacity: 0;
        }
      }
    `;
        document.head.appendChild(styles);
      }

      show({ title, message, type = 'info', duration = 5000 }) {
        const container = document.querySelector('.notification-container');
        const notification = document.createElement('div');

        // Set notification content
        notification.className = `notification ${type}`;
        notification.innerHTML = `
      <div class="notification-icon">
        <span class="material-icons">
          ${this.getIcon(type)}
        </span>
      </div>
      <div class="notification-content">
        <div class="notification-title">${title}</div>
        <div class="notification-message">${message}</div>
      </div>
      <button class="notification-close">
        <span class="material-icons">close</span>
      </button>
      <div class="notification-progress">
        <div class="notification-progress-bar"></div>
      </div>
    `;

        // Add to container
        container.appendChild(notification);

        // Setup progress bar
        const progressBar = notification.querySelector('.notification-progress-bar');
        progressBar.style.width = '100%';
        progressBar.style.transitionDuration = `${duration}ms`;

        // Start progress
        requestAnimationFrame(() => {
          progressBar.style.width = '0%';
        });

        // Setup close button
        const closeBtn = notification.querySelector('.notification-close');
        closeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          this.remove(notification);
        });

        // Setup swipe to dismiss
        let startX = 0;
        let currentX = 0;

        notification.addEventListener('touchstart', (e) => {
          startX = e.touches[0].clientX;
        });

        notification.addEventListener('touchmove', (e) => {
          currentX = e.touches[0].clientX;
          const diff = currentX - startX;
          if (diff < 0) {
            notification.style.transform = `translateX(${diff}px)`;
          }
        });

        notification.addEventListener('touchend', () => {
          const diff = currentX - startX;
          if (diff < -100) {
            this.remove(notification);
          } else {
            notification.style.transform = '';
          }
        });

        // Auto remove after duration
        if (duration) {
          setTimeout(() => {
            if (container.contains(notification)) {
              this.remove(notification);
            }
          }, duration);
        }
      }

      remove(notification) {
        notification.classList.add('removing');
        setTimeout(() => {
          notification.remove();
        }, 300);
      }

      getIcon(type) {
        switch (type) {
          case 'success': return 'check_circle';
          case 'error': return 'error';
          case 'warning': return 'warning';
          case 'info': return 'info';
          default: return 'info';
        }
      }
    }

    // Create global instance
    window.notifications = new NotificationManager();

    // Usage examples:
    function showNotification(type, title, message, duration = 5000) {
      window.notifications.show({
        type,
        title,
        message,
        duration
      });
    }
    //usage
    // Show different types of notifications
    // showNotification('success', 'Success!', 'Operation completed successfully');
    // showNotification('error', 'Error!', 'Something went wrong');
    // showNotification('warning', 'Warning', 'Please backup before proceeding');
    // showNotification('info', 'Info', 'New update available');

    // // With custom duration (in milliseconds)
    // showNotification('info', 'Quick Note', 'This will disappear in 2 seconds', 2000);
  </script>
  <script>
    // Add enhanced progress loading styles
    const progressLoadingStyles = document.createElement('style');
    progressLoadingStyles.textContent = `
  /* Progress Skeleton Loading Styles */
  .progress-skeleton {
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(
      90deg,
      var(--surface-color) 25%,
      var(--card-color) 50%,
      var(--surface-color) 75%
    );
    background-size: 200% 100%;
    animation: shimmer 1.5s infinite;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
  }

  /* Progress Bar Loading State */
  .progress-bar.loading {
    height: 12px;
    opacity: 0.3;
    transition: all 0.3s ease;
  }

  /* Progress Bar Loading Animation */
  @keyframes shimmer {
    0% { background-position: -200% 0; }
    100% { background-position: 200% 0; }
  }

  /* Time Indicator Loading State */
  .time-indicator.loading {
    opacity: 0.5;
    animation: pulse 1.5s infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 0.5; }
    50% { opacity: 0.2; }
  }

  /* Mobile Specific Progress Bar Adjustments */
  @media (max-width: 768px) {
    .progress-bar.loading {
      height: 14px;
    }
  }
`;
    document.head.appendChild(progressLoadingStyles);

    // Enhanced progress loading management
    function enhanceProgressLoading() {
      const audio = E.audio;
      const miniProgress = E.progressBar;
      const fullProgress = E.fullProgressBar;
      const progressSkeleton = E.progressSkeleton;
      const timeIndicators = document.querySelectorAll('.time-indicator');
      const progressBars = document.querySelectorAll('.progress-bar');

      function showLoading() {
        progressSkeleton.style.opacity = "1";
        progressBars.forEach(bar => bar.classList.add('loading'));
        timeIndicators.forEach(indicator => indicator.classList.add('loading'));
      }

      function hideLoading() {
        progressSkeleton.style.opacity = "0";
        progressBars.forEach(bar => bar.classList.remove('loading'));
        timeIndicators.forEach(indicator => indicator.classList.remove('loading'));
      }

      // Show loading on audio events
      audio.addEventListener('loadstart', showLoading);
      audio.addEventListener('waiting', showLoading);
      audio.addEventListener('seeking', showLoading);
      audio.addEventListener('stalled', showLoading);

      // Hide loading when ready
      audio.addEventListener('canplay', hideLoading);
      audio.addEventListener('playing', hideLoading);
      audio.addEventListener('seeked', hideLoading);

      // Handle errors
      audio.addEventListener('error', () => {
        hideLoading();
        showToast('error', 'Playback Error', 'Failed to load audio. Please try again.');
      });

      // Modify setupInitialSong to show loading state immediately
      const originalSetupInitialSong = window.setupInitialSong;
      window.setupInitialSong = async function () {
        showLoading(); // Show loading immediately
        try {
          await originalSetupInitialSong.apply(this, arguments);
        } catch (error) {
          console.error('Setup initial song error:', error);
          hideLoading();
        }
      };

      // Show loading state initially if not ready
      if (audio.readyState < 3) {
        showLoading();
      }
    }

    // Initialize the enhanced progress loading
    document.addEventListener('DOMContentLoaded', enhanceProgressLoading);
  </script>
  <script>
    //  async function setFavicons() {
    //       const response = await fetch('/data/download/icons/sangeet-home');
    //       const data = await response.json();
    //       const base64Data = data.base64;

    //       const sizes = [16, 32, 48, 64, 128, 256];
    //       sizes.forEach(size => {
    //           const link = document.createElement('link');
    //           link.rel = 'icon';
    //           link.type = 'image/png';
    //           link.sizes = `${size}x${size}`;
    //           link.href = `data:image/png;base64,${base64Data}`;
    //           document.head.appendChild(link);
    //       });
    //   }

    //   // Call the function to set favicons
    //   setFavicons();
    // async function setGifFavicon() {
    //       const response = await fetch('/data/download/icons/sangeet-home'); // Adjust the route as needed
    //       const data = await response.json();
    //       const base64Gif = data.base64;

    //       // Define common sizes for favicons
    //       const sizes = [16, 32, 48, 64, 128, 256];

    //       // Clear any existing favicons
    //       const existingFavicons = document.querySelectorAll('link[rel="icon"]');
    //       existingFavicons.forEach(favicon => favicon.remove());

    //       // Add new favicons for each size
    //       sizes.forEach(size => {
    //           const link = document.createElement('link');
    //           link.rel = 'icon';
    //           link.type = 'image/gif';
    //           link.sizes = `${size}x${size}`;
    //           link.href = `data:image/gif;base64,${base64Gif}`;
    //           document.head.appendChild(link);
    //       });
    //   }

    //   // Call the function to set the GIF favicon
    //   setGifFavicon();
  </script>
  <script>

    // Enhanced progress bar touch handling
    function setupProgressBar(container, progressHover, callback) {
      if (!container || !progressHover) return;

      let isDragging = false;
      let touchStartX = 0;
      let lastUpdateTime = 0;
      const updateThreshold = 50; // Minimum time between updates in ms

      // Touch start handler
      container.addEventListener("touchstart", (e) => {
        e.preventDefault();
        isDragging = true;
        touchStartX = e.touches[0].clientX;

        // Show visual feedback
        container.querySelector('.progress-bar').style.height =
          window.innerWidth <= 768 ? '14px' : '12px';
      });

      // Enhanced touch move handler with throttling
      container.addEventListener("touchmove", (e) => {
        if (!isDragging) return;

        const currentTime = Date.now();
        if (currentTime - lastUpdateTime < updateThreshold) return;

        const touch = e.touches[0];
        const rect = container.getBoundingClientRect();
        const percent = Math.max(0, Math.min(1, (touch.clientX - rect.left) / rect.width));

        progressHover.style.width = `${percent * 100}%`;

        if (E.audio.duration) {
          E.audio.currentTime = E.audio.duration * percent;
          lastUpdateTime = currentTime;
        }
      }, { passive: false });

      // Touch end handler
      container.addEventListener("touchend", (e) => {
        isDragging = false;
        container.querySelector('.progress-bar').style.height =
          window.innerWidth <= 768 ? '10px' : '8px';
      });

      // Mouse handling with enhanced sensitivity
      container.addEventListener("mousedown", (e) => {
        isDragging = true;
        const rect = container.getBoundingClientRect();
        const percent = (e.clientX - rect.left) / rect.width;

        if (E.audio.duration) {
          E.audio.currentTime = E.audio.duration * percent;
        }
      });

      container.addEventListener("mousemove", (e) => {
        const rect = container.getBoundingClientRect();
        const percent = ((e.clientX - rect.left) / rect.width) * 100;
        progressHover.style.width = `${percent}%`;

        if (isDragging && E.audio.duration) {
          E.audio.currentTime = E.audio.duration * (percent / 100);
        }
      });

      // Global mouse up handler
      document.addEventListener("mouseup", () => {
        isDragging = false;
      });

      // Prevent text selection while dragging
      container.addEventListener('selectstart', (e) => {
        if (isDragging) e.preventDefault();
      });
    }

    // Initialize enhanced progress bars
    document.addEventListener('DOMContentLoaded', () => {
      setupProgressBar(E.progressContainer, E.progressHover);
      setupProgressBar(E.fullProgressContainer, E.fullProgressHover);
    });
  </script>
  <script>
    /**
 * Session Management Enhancement
 */
    class SessionManager {
      constructor() {
        this.checkInterval = 10000; // Check every 10 seconds
        this.isCheckingSession = false;
        this.sessionInvalidated = false;
        this.initialize();
      }

      initialize() {
        // Start periodic checks
        this.startChecking();

        // Listen for visibility changes
        document.addEventListener('visibilitychange', () => {
          if (document.visibilityState === 'visible') {
            this.checkSessionStatus();
          }
        });

        // Check when user interacts after inactivity
        let lastActivity = Date.now();
        const activityEvents = ['mousedown', 'keydown', 'touchstart', 'click'];

        activityEvents.forEach(event => {
          document.addEventListener(event, () => {
            const now = Date.now();
            if (now - lastActivity > 30000) { // If inactive for 30s
              this.checkSessionStatus();
            }
            lastActivity = now;
          });
        });
      }

      async checkSessionStatus() {
        if (this.isCheckingSession || this.sessionInvalidated) return;

        this.isCheckingSession = true;

        try {
          const response = await fetch('/api/session-status');
          const data = await response.json();

          if (!response.ok || !data.valid) {
            this.sessionInvalidated = true;
            this.showSessionPopup(data.reason);
          }
        } catch (error) {
          console.error('Session check error:', error);
        } finally {
          this.isCheckingSession = false;
        }
      }

      startChecking() {
        setInterval(() => this.checkSessionStatus(), this.checkInterval);
      }

      showSessionPopup(reason) {
        // Stop all audio playback
        if (window.E && window.E.audio) {
          window.E.audio.pause();
        }

        // Create popup elements
        const overlay = document.createElement('div');
        overlay.className = 'session-popup-overlay';

        const popup = document.createElement('div');
        popup.className = 'session-popup';

        let title, message;
        switch (reason) {
          case 'logged_out_elsewhere':
            title = 'Session Ended';
            message = 'Your account has been logged in from another device. For security reasons, this session has been closed.';
            break;
          case 'expired':
            title = 'Session Expired';
            message = 'Your session has expired. Please log in again to continue.';
            break;
          default:
            title = 'Connection Lost';
            message = 'Your session is no longer active. Please log in again to continue.';
        }

        popup.innerHTML = `
      <div class="session-popup-icon">
        <span class="material-icons">error_outline</span>
      </div>
      <div class="session-popup-title">${title}</div>
      <div class="session-popup-message">${message}</div>
      <button class="session-popup-button">Login Again</button>
    `;

        // Add to document
        document.body.appendChild(overlay);
        document.body.appendChild(popup);

        // Handle button click
        const button = popup.querySelector('button');
        button.addEventListener('click', () => {
          window.location.href = '/login';
        });
      }
    }

    // Initialize session manager
    document.addEventListener('DOMContentLoaded', () => {
      window.sessionManager = new SessionManager();
    });
    class FestiveBackgroundSystem {
      constructor() {
        this.particleInterval = null;
        this.fps = 60;
        this.styles = `
      .bg-animation-wrapper {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: -1;
        overflow: hidden;
        pointer-events: none;
      }

      .festive-background {
        position: absolute;
        inset: -50px;
        opacity: 0.3;
        background: linear-gradient(
          45deg,
          #ff9a9e,    /* Light pink */
          #fad0c4,    /* Peach */
          #a18cd1,    /* Light purple */
          #fbc2eb,    /* Pink */
          #ff5458,    /* Bright red */
          #ffc853,    /* Yellow */
          #70ff57,    /* Green */
          #45caff     /* Blue */
        );
        background-size: 800% 800%;
        animation:
          gradientFlow 30s ease infinite,
          colorPulse 15s ease-in-out infinite;
        filter: blur(100px);
      }

      .festive-background::after {
        content: '';
        position: absolute;
        inset: 0;
        background: radial-gradient(
          circle at center,
          transparent 0%,
          rgba(0, 0, 0, 0.2) 100%
        );
      }

      .festive-particle {
        position: fixed;
        pointer-events: none;
        width: 10px;
        height: 10px;
        background: white;
        border-radius: 50%;
        opacity: 0;
        z-index: -1;
        transform-origin: center;
        will-change: transform, opacity;
      }

      @keyframes gradientFlow {
        0% { background-position: 0% 0%; }
        25% { background-position: 100% 50%; }
        50% { background-position: 50% 100%; }
        75% { background-position: 0% 50%; }
        100% { background-position: 0% 0%; }
      }

      @keyframes colorPulse {
        0%, 100% { filter: blur(100px) hue-rotate(0deg); }
        25% { filter: blur(100px) hue-rotate(90deg); }
        50% { filter: blur(100px) hue-rotate(180deg); }
        75% { filter: blur(100px) hue-rotate(270deg); }
      }

      @keyframes particleFloat {
        0% {
          transform: translateY(0) rotate(0deg);
          opacity: 0;
        }
        20% { opacity: 0.8; }
        100% {
          transform: translateY(-100vh) rotate(360deg);
          opacity: 0;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        .festive-background {
          animation: none;
          background-size: 100% 100%;
          background-position: center;
        }
        .festive-particle {
          display: none;
        }
      }
    `;

        this.colors = [
          '#FF5458', // Red (Gulal)
          '#FFC853', // Yellow (Turmeric)
          '#70FF57', // Green (Spring)
          '#45CAFF', // Blue (Sky)
          '#FF9A9E', // Pink
          '#FAD0C4', // Peach
          '#A18CD1', // Purple
          '#FBC2EB'  // Light pink
        ];

        this.init();
      }

      init() {
        this.injectStyles();
        this.createBackgroundElements();
        this.startParticleSystem();
        this.setupPerformanceMonitoring();
        this.handleVisibilityChange();
      }

      injectStyles() {
        const styleSheet = document.createElement('style');
        styleSheet.textContent = this.styles;
        document.head.appendChild(styleSheet);
      }

      createBackgroundElements() {
        const wrapper = document.createElement('div');
        wrapper.className = 'bg-animation-wrapper';

        const background = document.createElement('div');
        background.className = 'festive-background';

        wrapper.appendChild(background);
        document.body.appendChild(wrapper);
      }

      createParticle() {
        if (document.hidden) return;

        const particle = document.createElement('div');
        particle.className = 'festive-particle';

        // Random properties
        const size = Math.random() * 15 + 5;
        const left = Math.random() * 100;
        const duration = Math.random() * 2 + 2;
        const color = this.colors[Math.floor(Math.random() * this.colors.length)];

        particle.style.cssText = `
      left: ${left}vw;
      width: ${size}px;
      height: ${size}px;
      background: ${color};
      animation: particleFloat ${duration}s ease-in-out forwards;
      box-shadow: 0 0 ${size / 2}px rgba(255,255,255,0.5);
    `;

        document.body.appendChild(particle);

        // Clean up particle
        particle.addEventListener('animationend', () => {
          particle.remove();
        });
      }

      startParticleSystem() {
        const spawnParticles = () => {
          if (document.hidden) return;
          const count = this.fps > 30 ? 3 : 1;
          for (let i = 0; i < count; i++) {
            this.createParticle();
          }
        };

        this.particleInterval = setInterval(spawnParticles, 1000);
      }

      setupPerformanceMonitoring() {
        let frameCount = 0;
        let lastTime = performance.now();

        const checkPerformance = () => {
          frameCount++;
          const currentTime = performance.now();

          if (currentTime - lastTime >= 1000) {
            this.fps = frameCount;
            frameCount = 0;
            lastTime = currentTime;
          }

          requestAnimationFrame(checkPerformance);
        };

        requestAnimationFrame(checkPerformance);
      }

      handleVisibilityChange() {
        document.addEventListener('visibilitychange', () => {
          if (document.hidden) {
            clearInterval(this.particleInterval);
          } else {
            this.startParticleSystem();
          }
        });
      }
    }

    // Initialize the system when the DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
      window.festiveBackground = new FestiveBackgroundSystem();
    });
  </script>
  <script>
    // Enhanced smooth seeking with both slide and tap support
    function initializeSmoothSeek() {
      const progressContainer = document.querySelector('.progress-container');
      const progressBar = document.querySelector('.progress-bar');
      const progress = document.querySelector('.progress');

      if (!progressContainer || !progressBar || !progress) return;

      let isDragging = false;
      let startX = 0;
      let startProgress = 0;

      // Touch event handlers
      progressContainer.addEventListener('touchstart', (e) => {
        isDragging = true;
        startX = e.touches[0].clientX;
        startProgress = progress.style.width ? parseInt(progress.style.width) : 0;

        // Get immediate seek position on tap
        const rect = progressContainer.getBoundingClientRect();
        const percent = (e.touches[0].clientX - rect.left) / rect.width;
        if (E.audio.duration) {
          E.audio.currentTime = E.audio.duration * percent;
          syncProgress();
        }
      }, { passive: true });

      progressContainer.addEventListener('touchmove', (e) => {
        if (!isDragging) return;

        const rect = progressContainer.getBoundingClientRect();
        const percent = (e.touches[0].clientX - rect.left) / rect.width;
        const boundedPercent = Math.max(0, Math.min(1, percent));

        progress.style.width = `${boundedPercent * 100}%`;

        if (E.audio.duration) {
          E.audio.currentTime = E.audio.duration * boundedPercent;
          syncProgress();
        }
      }, { passive: true });

      progressContainer.addEventListener('touchend', () => {
        isDragging = false;
      });

      // Mouse event handlers
      progressContainer.addEventListener('mousedown', (e) => {
        isDragging = true;
        startX = e.clientX;
        startProgress = progress.style.width ? parseInt(progress.style.width) : 0;

        const rect = progressContainer.getBoundingClientRect();
        const percent = (e.clientX - rect.left) / rect.width;
        if (E.audio.duration) {
          E.audio.currentTime = E.audio.duration * percent;
          syncProgress();
        }
      });

      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;

        const rect = progressContainer.getBoundingClientRect();
        const percent = (e.clientX - rect.left) / rect.width;
        const boundedPercent = Math.max(0, Math.min(1, percent));

        progress.style.width = `${boundedPercent * 100}%`;

        if (E.audio.duration) {
          E.audio.currentTime = E.audio.duration * boundedPercent;
          syncProgress();
        }
      });

      document.addEventListener('mouseup', () => {
        isDragging = false;
      });
    }
    // Initialize
    document.addEventListener('DOMContentLoaded', initializeSmoothSeek);
  </script>
  <script>
    function formatTime(seconds) {
      if (!seconds || isNaN(seconds)) seconds = 0;
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);
      return hours > 0
        ? `${hours}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`
        : `${minutes}:${String(secs).padStart(2, '0')}`;
    }
  </script>
 
  <script>
    class PlaylistManager {
      constructor() {
        this.init();
      }

      /** Initialize elements and event listeners */
      init() {
        // Get DOM elements
        this.playlistModal = document.getElementById('playlistModal');
        this.closeButton = this.playlistModal.querySelector('.close-button');
        this.modalHeader = this.playlistModal.querySelector('#modalHeader');
        this.createPlaylistSection = this.playlistModal.querySelector('#createPlaylistSection');
        this.newPlaylistName = this.playlistModal.querySelector('#newPlaylistName');
        this.submitPlaylistBtn = this.playlistModal.querySelector('#submitPlaylistBtn');
        this.cancelPlaylistBtn = this.playlistModal.querySelector('#cancelPlaylistBtn');
        this.createPlaylistBtn = this.playlistModal.querySelector('#createPlaylistBtn');
        this.playlistList = this.playlistModal.querySelector('#playlistList');

        // Event listeners
        this.closeButton.addEventListener('click', () => {
          this.playlistModal.style.display = 'none';
        });

        this.createPlaylistBtn.addEventListener('click', () => {
          this.createPlaylistSection.style.display = 'block';
          this.createPlaylistBtn.style.display = 'none';
          this.newPlaylistName.focus();
        });

        this.cancelPlaylistBtn.addEventListener('click', () => {
          this.createPlaylistSection.style.display = 'none';
          this.createPlaylistBtn.style.display = 'block';
          this.newPlaylistName.value = '';
        });

        this.submitPlaylistBtn.addEventListener('click', () => this.createNewPlaylist());

        this.newPlaylistName.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') this.createNewPlaylist();
        });

        // // Example triggers to open the modal
        // document.querySelector('.menu-item[data-action="playlists"]').addEventListener('click', () => {
        //   this.openPlaylistModal(false);
        // });

        // document.getElementById('addToPlaylistButton').addEventListener('click', () => {
        //   this.openPlaylistModal(true);
        // });
            document.getElementById('addToPlaylistButton').addEventListener('click', () => {
          this.openPlaylistModal(true);
        });
      }

      /** Open the playlist modal in view or add mode */
      async openPlaylistModal(isAddMode) {
        this.playlistModal.style.display = 'block';
        this.playlistList.innerHTML = '<div class="skeleton-loading" style="height: 50px;"></div>';

        if (isAddMode) {
          const songTitle = document.getElementById('fullPlayerTitle').textContent || 'Current Song';
          this.modalHeader.textContent = `Add "${songTitle}" to Playlist`;
        } else {
          this.modalHeader.textContent = 'Playlists';
        }

        try {
          const response = await fetch('/api/playlists');
          if (!response.ok) throw new Error('Failed to fetch playlists');
          const playlists = await response.json();

          this.playlistList.innerHTML = '';
          playlists.forEach(playlist => {
            const item = document.createElement('div');
            item.className = 'playlist-item';
            item.innerHTML = `
          <div class="playlist-info">
            <div class="playlist-name">${playlist.name}</div>
            <div class="song-count">${playlist.song_count} songs</div>
          </div>
          <div class="playlist-controls">
            ${isAddMode ?
                `<button class="control-btn add-to-playlist" data-playlist-id="${playlist.id}" title="Add to Playlist">
                <span class="material-icons">add</span>
              </button>` :
                `<button class="control-btn play-playlist" data-playlist-id="${playlist.id}" title="Play Playlist">
                <span class="material-icons">play_arrow</span>
              </button>
              <button class="control-btn shuffle-playlist" data-playlist-id="${playlist.id}" title="Shuffle Playlist">
                <span class="material-icons">shuffle</span>
              </button>
              <button class="control-btn share-playlist" data-playlist-id="${playlist.id}" title="Share Playlist">
                <span class="material-icons">share</span>
              </button>`}
          </div>
        `;
            this.playlistList.appendChild(item);

            if (isAddMode) {
              item.querySelector('.add-to-playlist').addEventListener('click', () => {
                this.addSongToPlaylist(playlist.id);
              });
            } else {
              item.addEventListener('click', () => this.showPlaylistSongs(playlist.id, playlist.name));
              item.querySelector('.play-playlist').addEventListener('click', (e) => {
                e.stopPropagation();
                this.playPlaylist(playlist.id, false);
              });
              item.querySelector('.shuffle-playlist').addEventListener('click', (e) => {
                e.stopPropagation();
                this.playPlaylist(playlist.id, true);
              });
              item.querySelector('.share-playlist').addEventListener('click', (e) => {
                e.stopPropagation();
                this.sharePlaylist(playlist.id);
              });
            }
          });
        } catch (error) {
          console.error('Error loading playlists:', error);
          this.playlistList.innerHTML = '<p>Failed to load playlists.</p>';
        }
      }

      /** Create a new playlist */
      async createNewPlaylist() {
        const name = this.newPlaylistName.value.trim();
        if (!name) {
          showToast('Please enter a playlist name', 'error');
          return;
        }

        try {
          const response = await fetch('/api/playlists/create', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name })
          });
          if (!response.ok) throw new Error('Failed to create playlist');
          showToast('Playlist created successfully!', 'success');
          this.createPlaylistSection.style.display = 'none';
          this.createPlaylistBtn.style.display = 'block';
          this.newPlaylistName.value = '';
          this.openPlaylistModal(false);
        } catch (error) {
          console.error('Error creating playlist:', error);
          showToast('Failed to create playlist', 'error');
        }
      }

      /** Add the current song to a playlist */
      async addSongToPlaylist(playlistId) {
        if (!state.currentSongId) {
          showToast('No song selected', 'error');
          return;
        }

        try {
          const response = await fetch('/api/playlists/add_song', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ playlist_id: playlistId, song_id: state.currentSongId })
          });
          if (!response.ok) throw new Error('Failed to add song');
          showToast('Song added to playlist!', 'success');
          this.playlistModal.style.display = 'none';
        } catch (error) {
          console.error('Error adding song to playlist:', error);
          showToast('Failed to add song', 'error');
        }
      }

      /** Display songs in a selected playlist */
      async showPlaylistSongs(playlistId, playlistName) {
        this.playlistList.innerHTML = '';

        const header = document.createElement('div');
        header.className = 'pl-header';
        header.innerHTML = `
      <button class="pl-back-btn"><span class="material-icons">arrow_back</span></button>
      <h3>${playlistName}</h3>
    `;
        this.playlistList.appendChild(header);

        header.querySelector('.pl-back-btn').addEventListener('click', () => {
          this.openPlaylistModal(false);
        });

        const skeleton = document.createElement('div');
        skeleton.className = 'skeleton-loading';
        skeleton.style.height = '50px';
        this.playlistList.appendChild(skeleton);

        try {
          const response = await fetch(`/api/playlists/${playlistId}/songs`);
          if (!response.ok) throw new Error('Failed to fetch playlist songs');
          const songs = await response.json();

          skeleton.remove();

          songs.forEach(song => {
            const songItem = document.createElement('div');
            songItem.className = 'pl-song-item';
            songItem.innerHTML = `
          <img src="${song.thumbnail || '/static/images/default-cover.png'}" alt="${song.title}" class="pl-song-thumb" loading="lazy">
          <div class="pl-song-info">
            <div class="pl-song-title">${song.title}</div>
            <div class="pl-song-artist">${song.artist}</div>
          </div>
          <button class="pl-control-btn pl-play-btn" data-song-id="${song.id}" title="Play Song">
            <span class="material-icons">play_arrow</span>
          </button>
        `;
            songItem.querySelector('.pl-play-btn').addEventListener('click', (e) => {
              e.stopPropagation();
              queueAndPlaySong(song.id);
            });
            this.playlistList.appendChild(songItem);
          });
        } catch (error) {
          console.error('Error loading playlist songs:', error);
          skeleton.remove();
          this.playlistList.innerHTML = '<p>Failed to load songs.</p>';
        }
      }

      /** Play a playlist, optionally shuffled */
      async playPlaylist(playlistId, shuffle) {
        try {
          const response = await fetch(`/api/playlists/${playlistId}/songs`);
          if (!response.ok) throw new Error('Failed to fetch playlist songs');
          const songs = await response.json();

          if (!songs.length) {
            showToast('Playlist is empty', 'warning');
            return;
          }

          state.queue = songs.map(song => song.id);
          state.queueIndex = -1;
          if (shuffle) {
            state.queue = state.queue.sort(() => Math.random() - 0.5);
          }
          playNext();
        } catch (error) {
          console.error('Error playing playlist:', error);
          showToast('Failed to play playlist', 'error');
        }
      }

      /** Share a playlist via Web Share API or clipboard */
      async sharePlaylist(playlistId) {
        try {
          const response = await fetch(`/api/playlists/${playlistId}/share`, { method: 'POST' });
          if (!response.ok) throw new Error('Failed to generate share link');
          const data = await response.json();
          const shareUrl = `${window.location.origin}/playlists/share/${data.share_id}`;

          if (navigator.share) {
            await navigator.share({
              title: 'Share Playlist',
              text: 'Check out my playlist!',
              url: shareUrl
            });
          } else {
            await navigator.clipboard.writeText(shareUrl);
            showToast('Playlist share link copied to clipboard!', 'success');
          }
        } catch (error) {
          console.error('Error sharing playlist:', error);
          showToast('Failed to share playlist', 'error');
        }
      }
    }

    // Initialize the playlist manager when the DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
      // new PlaylistManager();
      window.playlistManager = new PlaylistManager();
    });
  </script>
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Select DOM elements
      const fullPlayer = document.querySelector('.full-player');
      const fullPlayerContent = document.querySelector('.full-player-content');
      const minimizeButton = document.getElementById('minimizeButton');

      // Error handling: Check if required elements exist
      if (!fullPlayer || !fullPlayerContent) {
        console.error('Full player elements not found');
        return;
      }

      // Initialize variables
      let startY = 0;
      let currentY = 0;
      let isPulling = false;
      const threshold = window.innerHeight * 0.2; // 20% of screen height as threshold

      // Function to close the full player with animation
      function closeFullPlayer() {
        fullPlayer.style.transition = 'transform 0.4s ease, opacity 0.4s ease';
        fullPlayer.style.transform = 'translateY(100%)';
        fullPlayer.style.opacity = '0';
        setTimeout(() => {
          fullPlayer.classList.remove('active');
          fullPlayer.style.display = 'none';
          fullPlayer.style.transform = '';
          fullPlayer.style.opacity = '';
          fullPlayer.style.transition = '';
        }, 400); // Matches transition duration
      }

      // --- Touch Event Listeners for Mobile ---
      fullPlayer.addEventListener('touchstart', (e) => {
        // Only start pulling if content is at the top (or overscrolled)
        if (fullPlayerContent.scrollTop <= 0) {
          startY = e.touches[0].clientY;
          isPulling = true;
          fullPlayer.style.transition = ''; // Remove transition during pull
        }
      });

      fullPlayer.addEventListener('touchmove', (e) => {
        if (!isPulling) return;
        currentY = e.touches[0].clientY;
        const diff = currentY - startY;
        if (diff > 0) {
          // Translate player downward and adjust opacity for feedback
          fullPlayer.style.transform = `translateY(${diff}px)`;
          fullPlayer.style.opacity = Math.max(0.5, 1 - diff / (threshold * 2));
          e.preventDefault(); // Prevent pull-to-refresh or scrolling
        }
      }, { passive: false }); // Allow preventDefault()

      fullPlayer.addEventListener('touchend', () => {
        if (!isPulling) return;
        isPulling = false;
        const diff = currentY - startY;

        if (diff > threshold) {
          // Close the player if pulled beyond threshold
          closeFullPlayer();
        } else {
          // Snap back to original position
          fullPlayer.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
          fullPlayer.style.transform = 'translateY(0)';
          fullPlayer.style.opacity = '1';
          setTimeout(() => {
            fullPlayer.style.transition = '';
            fullPlayer.style.transform = '';
            fullPlayer.style.opacity = '';
          }, 300); // Matches snap-back duration
        }
      });

      // --- Mouse Event Listeners for Desktop ---
      fullPlayer.addEventListener('mousedown', (e) => {
        if (fullPlayerContent.scrollTop <= 0) {
          startY = e.clientY;
          isPulling = true;
          fullPlayer.style.transition = '';
        }
      });

      fullPlayer.addEventListener('mousemove', (e) => {
        if (!isPulling) return;
        currentY = e.clientY;
        const diff = currentY - startY;
        if (diff > 0) {
          fullPlayer.style.transform = `translateY(${diff}px)`;
          fullPlayer.style.opacity = Math.max(0.5, 1 - diff / (threshold * 2));
        }
      });

      document.addEventListener('mouseup', () => {
        if (!isPulling) return;
        isPulling = false;
        const diff = currentY - startY;

        if (diff > threshold) {
          closeFullPlayer();
        } else {
          fullPlayer.style.transition = 'transform 0.3s ease, opacity 0.3s ease';
          fullPlayer.style.transform = 'translateY(0)';
          fullPlayer.style.opacity = '1';
          setTimeout(() => {
            fullPlayer.style.transition = '';
            fullPlayer.style.transform = '';
            fullPlayer.style.opacity = '';
          }, 300);
        }
      });

      // Attach close function to minimize button (if it exists)
      if (minimizeButton) {
        minimizeButton.addEventListener('click', closeFullPlayer);
      }
    });

    function openFullPlayer() {
      E.fullPlayer.style.display = 'flex';
      requestAnimationFrame(() => {
        E.fullPlayer.classList.add('active');
      });
      onFullPlayerOpen();
    }


    E.expandButton.addEventListener('click', openFullPlayer);
  </script>
  <script>
    function createRipple(event) {
      const element = event.currentTarget;
      const ripple = document.createElement('span');
      ripple.classList.add('ripple');

      const rect = element.getBoundingClientRect();
      const x = (event.clientX || event.touches[0].clientX) - rect.left;
      const y = (event.clientY || event.touches[0].clientY) - rect.top;

      ripple.style.left = `${x}px`;
      ripple.style.top = `${y}px`;

      element.appendChild(ripple);

      setTimeout(() => {
        ripple.remove();
      }, 600);
    }

    document.querySelectorAll('.control-button, .song-card, .menu-item').forEach(el => {
      el.addEventListener('click', createRipple);
      el.addEventListener('touchstart', createRipple, { passive: true });
    });
  </script>
  <script>

    function checkProtocolAndShowWarning() {
      const overlay = document.getElementById('httpWarningOverlay');
      const closeButton = document.getElementById('httpWarningClose');
      const httpsLink = document.getElementById('httpsLink');

      // Function to show the warning
      function showWarning() {
        overlay.style.display = 'flex';
        const httpsUrl = `https://${window.location.hostname}${window.location.pathname}${window.location.search}`;
        httpsLink.href = httpsUrl;
        httpsLink.textContent = httpsUrl;

        // Auto-close after 10 seconds if still visible
        setTimeout(() => {
          if (overlay.style.display === 'flex') {
            overlay.style.display = 'none';
          }
        }, 10000);
      }

      // Function to hide the warning
      function hideWarning() {
        overlay.style.display = 'none';
      }

      // Attach close button listener once, outside the condition
      closeButton.addEventListener('click', hideWarning);

      // Check protocol and hostname, show warning if not HTTPS and not localhost or 127.0.0.1
      if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
        showWarning();
      }
    }

    // Call the function when the DOM is fully loaded
    document.addEventListener('DOMContentLoaded', () => {
      checkProtocolAndShowWarning();
    });
  </script>
  <script>
    /**
   * =========================================================================
   * Issue Reporting System - V3.2 (Corrected & Refactored IDs)
   * -------------------------------------------------------------------------
   * - Fixes hover/touch issues by correctly using `display: none`.
   * - Fixes aria-hidden focus conflict by managing focus on close.
   * - Refactors all internal IDs with `ic-` prefix to prevent conflicts.
   * - Links CSS dynamically.
   * =========================================================================
   */
    (function () {
      // --- Module State (Refactored IDs) ---
      let icModal = null, icCloseButton = null, icReportTabButton = null, icMyIssuesTabButton = null;
      let icReportModalBody = null, icReportFormView = null, icMyIssuesView = null, icIssueDetailView = null;
      let icIssuesLoading = null, icIssuesEmpty = null, icIssuesList = null;
      let icIssueDetailTitle = null, icIssueDetailContent = null, icIssueStatusBadge = null, icIssueStatusDate = null, icBackToIssuesButton = null;
      let icReportTopicInput = null, icReportDetailsInput = null, icSubmitIssueButton = null;
      let triggerElement = null; // Store element that opened the modal

      let currentView = 'report';
      let issuesLoaded = false;
      let selectedIssueId = null;
      let issuePollingIntervalId = null;
      const POLLING_INTERVAL_MS = 5000; // 5 seconds
      let lastIssueListDataHash = null;
      let lastIssueDetailDataHash = null;
      let isModalInitialized = false;
      const CSS_LINK_ID = 'ic-reportIssueModalStyles'; // Refactored ID
      const CSS_PATH = '/design/report-issues'; // Path to your modal CSS (adjust if needed)
      const MODAL_ID = 'ic-reportIssueModal'; // Refactored ID

      // --- Initialization ---
      function init() {
        if (isModalInitialized) return;
        console.log("Initializing Issue Center (v3.2)...");

        createModalStructure();
        updateDOMReferences();

        if (!icModal) {
          console.error("Issue Center Modal root element not found after creation.");
          return;
        }

        attachEventListeners();
        ensureModalCSSLink();
        setupWhatsNewEventListeners();
        connectToHamburgerMenu(); // Re-connects trigger after DOM update

        isModalInitialized = true;
        console.log("Issue Center Initialized (v3.2).");
      }

      // --- HTML Structure Creation (Refactored IDs) ---
      function createModalStructure() {
        if (document.getElementById(MODAL_ID)) return; // Use constant

        const modalContainer = document.createElement('div');
        modalContainer.id = MODAL_ID; // Use constant
        modalContainer.className = 'ic-report-issue-modal'; // CSS class can be different
        modalContainer.style.display = 'none'; // Start hidden correctly
        modalContainer.setAttribute('aria-hidden', 'true');
        modalContainer.setAttribute('role', 'dialog');
        modalContainer.setAttribute('aria-modal', 'true'); // Important for modal dialogs
        modalContainer.setAttribute('aria-labelledby', 'ic-issueCenterModalTitle'); // Refactored

        modalContainer.innerHTML = `
            <div class="ic-report-modal-content" role="document">
                <div class="ic-report-modal-header">
                    <h2 id="ic-issueCenterModalTitle">Issue Center</h2>
                    <button class="ic-report-close-button" id="ic-reportCloseButton" aria-label="Close Issue Center">
                        <span class="material-icons">close</span>
                    </button>
                </div>
                <div class="ic-report-tabs" role="tablist">
                    <button id="ic-reportTabButton" class="ic-report-tab active" data-view="report" role="tab" aria-selected="true" aria-controls="ic-reportFormView">Report Issue</button>
                    <button id="ic-myIssuesTabButton" class="ic-report-tab" data-view="issues" role="tab" aria-selected="false" aria-controls="ic-myIssuesView">My Issues</button>
                </div>
                <div class="ic-report-modal-body" id="ic-reportModalBody">
                    <!-- Views are added below -->
                </div>
            </div>`;
        document.body.appendChild(modalContainer);
        createViews(modalContainer.querySelector('#ic-reportModalBody')); // Refactored ID
      }

      function createViews(bodyElement) {
        if (!bodyElement) return;
        // Refactored IDs in view containers and controlled elements
        bodyElement.innerHTML = `
             <!-- Report Issue Form View -->
             <div id="ic-reportFormView" class="ic-report-view active" role="tabpanel" aria-labelledby="ic-reportTabButton">
                 <div class="ic-report-form-group"><label for="ic-reportTopic">Issue Topic</label><div class="ic-report-input-container"><span class="ic-report-input-icon material-icons">topic</span><input type="text" id="ic-reportTopic" placeholder="Brief description..." autocomplete="off"></div></div>
                 <div class="ic-report-form-group"><label for="ic-reportDetails">Details</label><div class="ic-report-input-container ic-report-textarea-container"><span class="ic-report-input-icon material-icons">description</span><textarea id="ic-reportDetails" placeholder="Describe the issue..." rows="5"></textarea></div></div>
                 <div class="ic-report-form-actions"><button id="ic-submitIssueButton" class="ic-report-primary-button"><span class="material-icons">send</span> Submit Issue</button></div>
             </div>
             <!-- My Issues List View -->
             <div id="ic-myIssuesView" class="ic-report-view" role="tabpanel" aria-labelledby="ic-myIssuesTabButton">
                 <div class="ic-issues-loading" id="ic-issuesLoading" style="display: none;"><div class="ic-loading-spinner"></div><p>Loading...</p></div>
                 <div class="ic-issues-empty" id="ic-issuesEmpty" style="display: none;"><span class="material-icons" style="font-size: 48px;">inbox</span><p>No issues reported yet.</p></div>
                 <div class="ic-issues-list" id="ic-issuesList" aria-live="polite"></div>
             </div>
             <!-- Issue Detail View -->
             <div id="ic-issueDetailView" class="ic-report-view">
                 <div class="ic-issue-detail-header"><button id="ic-backToIssuesButton" class="ic-back-button" aria-label="Back to Issues List"><span class="material-icons">arrow_back</span></button><h3 id="ic-issueDetailTitle">Issue Details</h3></div>
                 <div class="ic-issue-detail-content" id="ic-issueDetailContent"></div>
                 <div class="ic-issue-detail-footer"><div class="ic-issue-status" id="ic-issueStatus"><span class="ic-status-badge open" id="ic-issueStatusBadge">Status</span><span class="ic-status-date" id="ic-issueStatusDate">Date</span></div></div>
                  <!-- Reply Section (Dynamically added) -->
             </div>
         `;
      }

      // --- Update DOM References (Refactored IDs) ---
      function updateDOMReferences() {
        icModal = document.getElementById(MODAL_ID);
        if (!icModal) return;
        icCloseButton = icModal.querySelector('#ic-reportCloseButton');
        icReportTabButton = icModal.querySelector('#ic-reportTabButton');
        icMyIssuesTabButton = icModal.querySelector('#ic-myIssuesTabButton');
        icReportModalBody = icModal.querySelector('#ic-reportModalBody');
        icReportFormView = icModal.querySelector('#ic-reportFormView');
        icMyIssuesView = icModal.querySelector('#ic-myIssuesView');
        icIssueDetailView = icModal.querySelector('#ic-issueDetailView');
        icIssuesLoading = icModal.querySelector('#ic-issuesLoading');
        icIssuesEmpty = icModal.querySelector('#ic-issuesEmpty');
        icIssuesList = icModal.querySelector('#ic-issuesList');
        icIssueDetailTitle = icModal.querySelector('#ic-issueDetailTitle');
        icIssueDetailContent = icModal.querySelector('#ic-issueDetailContent');
        icIssueStatusBadge = icModal.querySelector('#ic-issueStatusBadge');
        icIssueStatusDate = icModal.querySelector('#ic-issueStatusDate');
        icBackToIssuesButton = icModal.querySelector('#ic-backToIssuesButton');
        icReportTopicInput = icModal.querySelector('#ic-reportTopic');
        icReportDetailsInput = icModal.querySelector('#ic-reportDetails');
        icSubmitIssueButton = icModal.querySelector('#ic-submitIssueButton');
      }

      // --- Attach Event Listeners ---
      function attachEventListeners() {
        if (!icModal) return;
        icCloseButton?.addEventListener('click', closeModal);
        icReportTabButton?.addEventListener('click', () => switchTab('report'));
        icMyIssuesTabButton?.addEventListener('click', () => switchTab('issues'));
        icBackToIssuesButton?.addEventListener('click', backToIssuesList);
        icSubmitIssueButton?.addEventListener('click', submitIssue);

        // Close on background click
        icModal.addEventListener('click', (e) => {
          if (e.target === icModal) closeModal();
        });
        // Close on Escape key
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && icModal?.style.display !== 'none') {
            closeModal();
          }
        });
      }

      // --- Link CSS ---
      function ensureModalCSSLink() {
        if (document.getElementById(CSS_LINK_ID)) return;
        const link = document.createElement('link');
        link.id = CSS_LINK_ID;
        link.rel = 'stylesheet';
        link.href = CSS_PATH; // Make sure this path is correct
        document.head.appendChild(link);
        console.log("Linked Issue Center CSS:", CSS_PATH);
      }

      // --- Core Modal/Tab Functions (Corrected open/close logic) ---
      window.openIssueModal = function (tab = 'report') {
        if (!isModalInitialized) init();
        if (!icModal) { console.error('Cannot open Issue Center Modal.'); return; }

        // Store the element that triggered the modal for focus return
        triggerElement = document.activeElement;

        icModal.style.display = 'flex'; // Make it visible for layout
        // Use requestAnimationFrame to ensure display is set before adding class for transition
        requestAnimationFrame(() => {
          icModal.classList.add('visible');
          icModal.setAttribute('aria-hidden', 'false');

          // Focus trapping: Focus the first focusable element (e.g., close button)
          icCloseButton?.focus();
        });


        // Set initial tab without transition animation glitch
        const reportView = getViewElement('report');
        const issuesView = getViewElement('issues');
        const detailView = getViewElement('detail');
        const isReportTab = tab === 'report';
        const isIssuesTab = tab === 'issues';
        reportView?.classList.toggle('active', isReportTab);
        issuesView?.classList.toggle('active', isIssuesTab);
        detailView?.classList.toggle('active', false); // Detail never opens first
        icReportTabButton?.classList.toggle('active', isReportTab);
        icMyIssuesTabButton?.classList.toggle('active', isIssuesTab);
        icReportTabButton?.setAttribute('aria-selected', isReportTab);
        icMyIssuesTabButton?.setAttribute('aria-selected', isIssuesTab);
        currentView = tab;

        if (tab === 'issues') {
          loadUserIssues().finally(() => startIssuePolling('list'));
        } else if (tab === 'report') {
          // Maybe focus the topic input when opening the report tab
          icReportTopicInput?.focus();
        }

        icReportModalBody?.scrollTo(0, 0); // Scroll to top on open
      };

      function closeModal() {
        if (!icModal || icModal.style.display === 'none') return; // Already closed

        stopIssuePolling();

        // 1. Start fade-out animation
        icModal.classList.remove('visible');

        // 2. Manage focus BEFORE hiding completely
        if (document.activeElement && icModal.contains(document.activeElement)) {
          // If focus is inside, try returning to trigger, else blur
          triggerElement?.focus();
          if (document.activeElement === triggerElement) {
            console.log("Focus returned to trigger");
          } else {
            (document.activeElement).blur(); // Fallback if trigger isn't focusable
            console.log("Blurred active element as trigger focus failed");
          }
        } else {
          console.log("Focus was outside modal, not changed.");
        }
        triggerElement = null; // Clear trigger reference


        // 3. Set aria-hidden and display:none AFTER animation (or use transitionend)
        // Using setTimeout is simpler here
        setTimeout(() => {
          icModal.style.display = 'none';
          icModal.setAttribute('aria-hidden', 'true');

          // Reset form fields
          if (icReportTopicInput) icReportTopicInput.value = '';
          if (icReportDetailsInput) icReportDetailsInput.value = '';
          selectedIssueId = null;
          // Do not reset issuesLoaded, preserve cache
        }, 300); // Match the CSS transition duration
      }

      function switchTab(newTab) {
        if (!icModal || newTab === currentView) return;
        stopIssuePolling();

        icReportTabButton?.classList.toggle('active', newTab === 'report');
        icMyIssuesTabButton?.classList.toggle('active', newTab === 'issues');
        icReportTabButton?.setAttribute('aria-selected', newTab === 'report');
        icMyIssuesTabButton?.setAttribute('aria-selected', newTab === 'issues');

        const oldViewElement = getViewElement(currentView);
        const newViewElement = getViewElement(newTab);

        // --- Simplified View Switching (using active class only) ---
        // Assuming CSS handles transitions based on the 'active' class
        if (oldViewElement) oldViewElement.classList.remove('active');
        if (newViewElement) newViewElement.classList.add('active');
        // --- End Simplified ---

        // --- OR Keep Slide Animation (Ensure CSS supports it) ---
        // const slideDirection = (newTab === 'report' || (currentView === 'detail' && newTab === 'issues')) ? 'right' : 'left';
        // if (oldViewElement) animateViewTransition(oldViewElement, `slide-${slideDirection}`, false);
        // if (newViewElement) animateViewTransition(newViewElement, `slide-${slideDirection === 'left' ? 'right' : 'left'}`, true);
        // --- End Slide Animation ---


        currentView = newTab;
        icReportModalBody?.scrollTo(0, 0); // Scroll to top when switching tabs

        if (newTab === 'issues') {
          loadUserIssues(!issuesLoaded).finally(() => {
            if (icModal?.style.display !== 'none' && currentView === 'issues') {
              startIssuePolling('list');
            }
          });
        }
      }

      function getViewElement(viewName) {
        if (!isModalInitialized) return null; // Don't try before init
        switch (viewName) {
          case 'report': return icReportFormView;
          case 'issues': return icMyIssuesView;
          case 'detail': return icIssueDetailView;
          default: return null;
        }
      }

      // --- Data Fetching and Display (Refactored IDs) ---
      async function loadUserIssues(showLoadingIndicator = true) {
        const displaySpinner = showLoadingIndicator && !issuesLoaded;
        if (displaySpinner) {
          if (icIssuesLoading) icIssuesLoading.style.display = 'flex';
          if (icIssuesEmpty) icIssuesEmpty.style.display = 'none';
          if (icIssuesList) icIssuesList.innerHTML = '';
        }
        try {
          const response = await fetch('/api/user-issues');
          if (!response.ok) throw new Error('Failed fetch');
          const data = await response.json();
          issuesLoaded = true;
          const currentHash = generateIssueDataHash(data);
          // Only update DOM if hash changed or it was the initial load with spinner
          if (currentHash !== lastIssueListDataHash || displaySpinner) {
            displayIssues(data);
            lastIssueListDataHash = currentHash;
          }
          return data;
        } catch (error) {
          console.error('Error loading issues:', error);
          if (displaySpinner) displayError();
          lastIssueListDataHash = null;
          throw error;
        } finally {
          // Always hide spinner if it was shown
          if (displaySpinner && icIssuesLoading) icIssuesLoading.style.display = 'none';
        }
      }

      function displayIssues(issues) {
        if (!icIssuesList || !icIssuesEmpty) return;
        icIssuesList.innerHTML = ''; // Clear previous

        if (!issues || issues.length === 0) {
          icIssuesEmpty.style.display = 'flex'; // Show empty state
          // Ensure content is set if it wasn't already
          if (!icIssuesEmpty.innerHTML.includes('inbox')) {
            icIssuesEmpty.innerHTML = `<span class="material-icons" style="font-size: 48px; margin-bottom: 10px;">inbox</span><p>No issues reported yet.</p>`;
          }
          return;
        }
        icIssuesEmpty.style.display = 'none'; // Hide empty state
        issues.sort((a, b) => new Date(b.updated_at) - new Date(a.created_at)); // Sort by most recently updated

        issues.forEach(issue => {
          const issueItem = document.createElement('button'); // Use button for accessibility
          issueItem.className = 'ic-issue-item'; // Refactored class
          issueItem.dataset.issueId = issue.id;
          issueItem.setAttribute('role', 'button');
          issueItem.setAttribute('aria-label', `View details for issue: ${issue.topic}`);
          const statusClass = issue.status.toLowerCase().replace(/\s+/g, '-');
          // Check if latest comment is admin AND different from last known user comment timestamp (more robust unread)
          const hasUnread = issue.comments?.length > 0 && issue.comments[issue.comments.length - 1].is_admin;

          issueItem.innerHTML = `
                 <div class="ic-issue-title ${hasUnread ? 'unread' : ''}">${escapeHtml(issue.topic)} ${hasUnread ? '<span class="ic-unread-indicator">â€¢</span>' : ''}</div>
                 <div class="ic-issue-meta">
                     <span class="ic-issue-date">Updated: ${formatDate(issue.updated_at, true)}</span>
                     <span class="ic-issue-status-badge ${statusClass}">${escapeHtml(issue.status)}</span>
                 </div>
            `;
          issueItem.addEventListener('click', () => viewIssueDetail(issue));
          icIssuesList.appendChild(issueItem);
        });
      }

      function viewIssueDetail(issue) {
        if (!issue || !issue.id || !isModalInitialized) { backToIssuesList(); return; }
        stopIssuePolling();
        selectedIssueId = issue.id;

        if (icIssueDetailTitle) icIssueDetailTitle.textContent = escapeHtml(issue.topic);
        if (!icIssueDetailContent) return;
        icIssueDetailContent.innerHTML = ''; // Clear previous

        const fragment = document.createDocumentFragment();

        // --- Original Description ---
        const descriptionBubble = document.createElement('div');
        descriptionBubble.className = 'ic-conversation-bubble ic-user-bubble'; // Refactored classes
        descriptionBubble.innerHTML = `<div class="ic-bubble-header"><span class="ic-bubble-author">You (Reported)</span><span class="ic-bubble-date">${formatDate(issue.created_at, true)}</span></div><div class="ic-bubble-content">${escapeHtml(issue.details || '')}</div>`;
        fragment.appendChild(descriptionBubble);

        // --- Discussion Section ---
        if (issue.comments && issue.comments.length > 0) {
          issue.comments.sort((a, b) => new Date(a.created_at) - new Date(b.created_at));
          issue.comments.forEach(comment => {
            const isAdmin = comment.is_admin;
            const authorLabel = isAdmin ? 'Sangeet Admin' : 'You';
            const bubbleClass = isAdmin ? 'ic-admin-bubble' : 'ic-user-bubble'; // Refactored classes
            const commentBubble = document.createElement('div');
            commentBubble.className = `ic-conversation-bubble ${bubbleClass}`; // Refactored classes
            commentBubble.innerHTML = `<div class="ic-bubble-header"><span class="ic-bubble-author">${escapeHtml(authorLabel)}</span><span class="ic-bubble-date">${formatDate(comment.created_at, true)}</span></div><div class="ic-bubble-content">${escapeHtml(comment.content)}</div>`;
            fragment.appendChild(commentBubble);
          });
        } else {
          const noResponseP = document.createElement('p');
          noResponseP.className = 'ic-no-responses'; // Refactored class
          noResponseP.textContent = 'No further discussion yet.';
          fragment.appendChild(noResponseP);
        }

        // --- Reply Section (Conditional) ---
        if (issue.status !== 'Closed') {
          const replySection = document.createElement('div');
          replySection.className = 'ic-user-reply-section'; // Refactored class
          // Refactored IDs for reply elements
          replySection.innerHTML = `
                <div class="ic-report-input-container ic-report-textarea-container">
                    <textarea id="ic-userReplyTextarea" placeholder="Type your reply..." rows="3" aria-label="Your reply"></textarea>
                </div>
                <div class="ic-reply-actions">
                    <button id="ic-submitUserReplyButton" class="ic-report-primary-button">
                        <span class="material-icons">send</span> Send
                    </button>
                </div>
                <div id="ic-userReplyError" class="ic-reply-error" aria-live="polite"></div>`;
          fragment.appendChild(replySection);
        } else {
          const closedNotice = document.createElement('div');
          closedNotice.className = 'ic-user-reply-section ic-issue-closed-notice'; // Refactored classes
          closedNotice.innerHTML = `<p><span class="material-icons">lock</span> Issue Closed. Replies disabled.</p>`;
          fragment.appendChild(closedNotice);
        }

        // Append fragment and attach listener AFTER appending
        icIssueDetailContent.appendChild(fragment);
        const submitReplyBtn = icIssueDetailContent.querySelector('#ic-submitUserReplyButton'); // Refactored ID
        submitReplyBtn?.addEventListener('click', submitUserReply);

        // --- Update Status Footer (Refactored IDs) ---
        if (icIssueStatusBadge) { icIssueStatusBadge.textContent = issue.status; icIssueStatusBadge.className = `ic-status-badge ${issue.status.toLowerCase().replace(/\s+/g, '-')}`; }
        if (icIssueStatusDate) icIssueStatusDate.textContent = `Updated: ${formatDate(issue.updated_at, true)}`;

        // --- Switch View & Start Polling ---
        // Switch using classes directly is simpler
        if (icMyIssuesView) icMyIssuesView.classList.remove('active');
        if (icIssueDetailView) icIssueDetailView.classList.add('active');
        currentView = 'detail';
        lastIssueDetailDataHash = generateSingleIssueDataHash(issue);
        icReportModalBody?.scrollTo({ top: icReportModalBody.scrollHeight, behavior: 'smooth' }); // Scroll to bottom
        startIssuePolling('detail');
      }

      function backToIssuesList() {
        if (!isModalInitialized) return;
        stopIssuePolling();

        if (icIssueDetailView) icIssueDetailView.classList.remove('active');
        if (icMyIssuesView) icMyIssuesView.classList.add('active');

        currentView = 'issues';
        selectedIssueId = null;
        lastIssueDetailDataHash = null;
        icReportModalBody?.scrollTo(0, 0); // Scroll list to top
        // Refresh list and start polling
        loadUserIssues(false).finally(() => {
          if (icModal?.style.display !== 'none' && currentView === 'issues') {
            startIssuePolling('list');
          }
        });
      }

      function displayError() {
        if (icIssuesEmpty) {
          icIssuesEmpty.style.display = 'flex';
          icIssuesEmpty.innerHTML = `<span class="material-icons" style="font-size: 48px;">error_outline</span><p>Failed to load issues.</p>`;
        }
        if (icIssuesList) icIssuesList.innerHTML = ''; // Clear any potential stale items
      }


      // --- Action Functions (Refactored IDs) ---
      function submitIssue() {
        if (!icReportTopicInput || !icReportDetailsInput || !icSubmitIssueButton) return;
        const topic = icReportTopicInput.value.trim();
        const details = icReportDetailsInput.value.trim();
        if (!topic || !details) { showToast('Topic and details required.', 'error'); return; }

        icSubmitIssueButton.disabled = true; icSubmitIssueButton.innerHTML = 'Submitting...';

        fetch('/api/report-issue', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ topic, details }) })
          .then(r => r.ok ? r.json() : r.json().then(e => Promise.reject(e)))
          .then(() => {
            icReportTopicInput.value = ''; icReportDetailsInput.value = '';
            showToast('Issue submitted!', 'success');
            issuesLoaded = false; // Force reload
            switchTab('issues');
          })
          .catch(e => showToast(e.error || 'Failed to submit.', 'error'))
          .finally(() => { icSubmitIssueButton.disabled = false; icSubmitIssueButton.innerHTML = '<span class="material-icons">send</span> Submit'; });
      }

      function submitUserReply() {
        if (!selectedIssueId || !isModalInitialized) return;
        // Use refactored IDs to find elements
        const textarea = icModal?.querySelector('#ic-userReplyTextarea');
        const button = icModal?.querySelector('#ic-submitUserReplyButton');
        const errorDiv = icModal?.querySelector('#ic-userReplyError');
        const comment = textarea?.value.trim();

        if (!textarea || !button) { console.error("Reply elements not found in submitUserReply"); return; }
        if (errorDiv) errorDiv.textContent = ''; // Clear previous errors
        if (!comment) { if (errorDiv) errorDiv.textContent = 'Reply cannot be empty.'; textarea.focus(); return; }

        button.disabled = true; button.innerHTML = 'Sending...';

        fetch(`/api/issues/${selectedIssueId}/reply`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ comment }) })
          .then(r => r.json().then(d => ({ ok: r.ok, data: d })))
          .then(({ ok, data }) => {
            if (!ok) throw new Error(data.error || 'Failed to send reply');
            textarea.value = ''; // Clear textarea on success
            showToast('Reply sent!', 'success');
            stopIssuePolling(); // Pause polling for manual refresh
            return fetch('/api/user-issues'); // Re-fetch all issues
          })
          .then(res => res.ok ? res.json() : Promise.reject('Refetch failed'))
          .then(issues => {
            const updatedIssue = issues.find(iss => iss.id == selectedIssueId);
            if (updatedIssue && currentView === 'detail') {
              // Re-render the detail view with new data, which restarts polling
              viewIssueDetail(updatedIssue);
            } else {
              // If not in detail view or issue not found, go back to list
              backToIssuesList();
            }
          })
          .catch(error => {
            console.error('Error sending/refreshing reply:', error);
            if (errorDiv) errorDiv.textContent = error.message === 'Refetch failed' ? 'Could not refresh view.' : (error.message || 'Send failed.');
            showToast('Failed to send reply.', 'error');
            // Resume polling only if still in detail view and polling isn't running
            if (currentView === 'detail' && !issuePollingIntervalId) startIssuePolling('detail');
          })
          .finally(() => {
            // Ensure button is re-enabled
            if (button) { button.disabled = false; button.innerHTML = '<span class="material-icons">send</span> Send'; }
          });
      }


      // --- Polling Functions ---
      // Hash functions remain the same, they operate on data structure, not IDs
      function generateIssueDataHash(issues) { if (!issues || !Array.isArray(issues)) return ''; try { return JSON.stringify(issues.map(iss => ({ i: iss.id, s: iss.status, u: iss.updated_at, cc: (iss.comments || []).length }))); } catch (e) { return `${Date.now()}`; } }
      function generateSingleIssueDataHash(issue) { if (!issue) return ''; try { const lc = issue.comments?.slice(-1)[0]?.created_at ?? ''; return JSON.stringify({ i: issue.id, s: issue.status, u: issue.updated_at, cc: (issue.comments || []).length, lc: lc }); } catch (e) { return `${Date.now()}`; } }

      function startIssuePolling(viewType) {
        stopIssuePolling(); // Ensure no duplicates
        const pollFunction = async () => {
          // Check if modal is still visible and on the correct view
          if (icModal?.style.display === 'none' || currentView !== viewType || !navigator.onLine) {
            stopIssuePolling();
            return;
          }
          try {
            const r = await fetch('/api/user-issues');
            if (!r.ok) { console.warn('Polling fetch failed:', r.status); return; } // Don't stop polling on server error
            const d = await r.json();

            if (viewType === 'list') {
              const h = generateIssueDataHash(d);
              if (h !== lastIssueListDataHash) {
                lastIssueListDataHash = h;
                if (currentView === 'issues') displayIssues(d); // Update list view
                console.log("Issue list updated via polling.");
              }
            } else if (viewType === 'detail' && selectedIssueId) {
              const i = d.find(x => x.id == selectedIssueId);
              if (i) {
                const h = generateSingleIssueDataHash(i);
                if (h !== lastIssueDetailDataHash) {
                  lastIssueDetailDataHash = h;
                  if (currentView === 'detail') viewIssueDetail(i); // Update detail view
                  console.log("Issue detail updated via polling.");
                }
              } else {
                // Issue disappeared (e.g., deleted by admin)
                showToast('Issue may have been removed or closed.', 'warning');
                backToIssuesList(); // Go back to list, stop polling for detail
              }
            }
          } catch (e) {
            console.error("Polling error:", e); // Log network errors but don't stop
          }
        };

        // Run immediately only if the modal is actually visible
        if (icModal?.style.display !== 'none') {
          pollFunction();
        }
        issuePollingIntervalId = setInterval(pollFunction, POLLING_INTERVAL_MS);
        console.log(`Polling started (${viewType}, Interval ID: ${issuePollingIntervalId})`);
      }

      function stopIssuePolling() {
        if (issuePollingIntervalId !== null) {
          clearInterval(issuePollingIntervalId);
          console.log(`Polling stopped (Interval ID: ${issuePollingIntervalId})`);
          issuePollingIntervalId = null;
        }
      }

      // --- Utility Functions ---
      function escapeHtml(unsafe) {
        if (typeof unsafe !== 'string') return unsafe ?? '';
        return unsafe
          .replace(/&/g, "&") // Use & for ampersand
          .replace(/</g, "<")
          .replace(/>/g, ">")
          .replace(/"/g, '"')
          .replace(/'/g, "'"); // Use HTML entity for single quote
      }
      function formatDate(dateString, includeTime = false) {
        if (!dateString) return '';
        try {
          const d = new Date(dateString);
          const opts = { year: 'numeric', month: 'short', day: 'numeric' };
          if (includeTime) {
            opts.hour = 'numeric';
            opts.minute = '2-digit';
            opts.hour12 = true;
          }
          // Use local timezone formatting which is generally preferred
          return d.toLocaleString(undefined, opts); // 'en-US' or let browser decide
        } catch (e) {
          console.warn("Invalid date format:", dateString, e);
          return 'Invalid Date';
        }
      }
      function showToast(message, type = 'info') {
        // Assumes a global showNotification function exists
        if (typeof window.showNotification === 'function') {
          window.showNotification(type, 'Issue Center', message);
        } else {
          console.log(`[Issue Center Toast-${type}]: ${message}`);
        }
      }
      function connectToHamburgerMenu() {
        // Use a more specific selector if possible, or keep the generic one
        const triggerSelector = '[data-action="report-issue"], .report-issue-trigger';
        let currentTrigger = document.querySelector(triggerSelector);

        if (currentTrigger) {
          // Remove old listener if reconnecting (important if init runs multiple times)
          const newTrigger = currentTrigger.cloneNode(true);
          currentTrigger.parentNode?.replaceChild(newTrigger, currentTrigger);
          currentTrigger = newTrigger; // Update reference

          currentTrigger.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            window.openIssueModal('report'); // Use the global function
          });
          console.log("Issue Center trigger connected.");
        } else {
          console.warn("Issue Center trigger not found (selector: '" + triggerSelector + "'). Modal must be opened programmatically via openIssueModal().");
        }
      }

      // --- Auto-initialize ---
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init(); // Call directly if DOM is already loaded
      }
    })();
  </script>
  <script>
    let whatsNewLoaded = false; // Track if content has been loaded

    // Function to fetch and render What's New content
    async function loadWhatsNewContent() {
      if (whatsNewLoaded) return; // Don't reload if already loaded

      if (!E.whatsNewContent) return;

      // Show loading skeleton
      E.whatsNewContent.innerHTML = '<div class="skeleton-loading" style="height: 200px; width: 100%;"></div>';

      try {
        const response = await fetch('/getproject-info'); // Your endpoint
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const markdownText = await response.text();

        // Render markdown using Marked.js (with basic sanitization)
        const renderedHtml = marked.parse(markdownText, { sanitize: true }); // Enable sanitizer

        E.whatsNewContent.innerHTML = renderedHtml;
        whatsNewLoaded = true; // Mark as loaded

      } catch (error) {
        console.error('Error loading What\'s New content:', error);
        E.whatsNewContent.innerHTML = '<p style="color: var(--error-color);">Failed to load What\'s New information. Please try again later.</p>';
        whatsNewLoaded = false; // Allow retrying later
      }
    }

    // Function to open the modal
    function openWhatsNewModal() {
      if (!E.whatsNewModal) return;
      E.whatsNewModal.style.display = 'flex';
      requestAnimationFrame(() => { // Ensure display:flex is applied before adding class
        E.whatsNewModal.classList.add('visible'); // Use your existing 'visible' class if you have one for modal transitions
      });
      E.whatsNewModal.setAttribute('aria-hidden', 'false');
      E.closeWhatsNewModal.focus(); // Focus the close button for accessibility

      // Load content when opened (if not already loaded)
      loadWhatsNewContent();
    }

    // Function to close the modal
    function closeWhatsNewModal() {
      if (!E.whatsNewModal) return;
      E.whatsNewModal.classList.remove('visible');
      E.whatsNewModal.setAttribute('aria-hidden', 'true');

      // Use setTimeout matching CSS transition duration to set display:none
      setTimeout(() => {
        E.whatsNewModal.style.display = 'none';
      }, 300); // Adjust timing (e.g., 300ms) to match your CSS transition duration
    }

    // --- Event Listeners for What's New Modal ---
    // (Ensure these are called after the DOM is ready, e.g., inside your main init() or DOMContentLoaded)

    function setupWhatsNewEventListeners() {
      if (E.closeWhatsNewModal) {
        E.closeWhatsNewModal.addEventListener('click', closeWhatsNewModal);
      }

      if (E.whatsNewModal) {
        // Close on background click
        E.whatsNewModal.addEventListener('click', (e) => {
          if (e.target === E.whatsNewModal) {
            closeWhatsNewModal();
          }
        });
      }

      // Add listener for the new menu item
      const whatsNewTrigger = document.querySelector('.menu-item[data-action="whats-new"]');
      if (whatsNewTrigger) {
        whatsNewTrigger.addEventListener('click', openWhatsNewModal);
      }

      // Global Escape key listener (might already exist, ensure it handles this modal)
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && E.whatsNewModal && E.whatsNewModal.style.display === 'flex') {
          closeWhatsNewModal();
        }
      });
    }

  </script>
  <script>
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'hidden') {
        if (state.isPlaying && currentListenId && E.audio && E.audio.currentTime > 0) {
          console.log('Page hidden, ending listening session for:', state.currentSongId);
          // Send current progress. Backend's endListeningSession will finalize this.
          endListeningSession(Math.round(E.audio.duration), Math.round(E.audio.currentTime));
        }
      }
    });

    window.addEventListener('beforeunload', (event) => {
      if (state.isPlaying && currentListenId && E.audio && E.audio.currentTime > 0) {
        console.log('Page unloading, attempting to end listening session via Beacon API for:', state.currentSongId);
        if (navigator.sendBeacon) {
          const data = JSON.stringify({
            listenId: currentListenId,
            duration: Math.round(E.audio.duration),
            listenedDuration: Math.round(E.audio.currentTime)
          });
          // Ensure your /api/listen/end endpoint can handle 'application/json' from sendBeacon
          navigator.sendBeacon('/api/listen/end', new Blob([data], { type: 'application/json' }));
          console.log('Sent session end data via Beacon API for listenId:', currentListenId);
        } else {
          // Synchronous XHR as a last resort (highly unreliable)
          // Consider removing if sendBeacon is widely supported enough for your target users.
          // For a truly robust solution without sendBeacon, periodic updates are better.
          console.warn("navigator.sendBeacon not available. Session end on unload might be unreliable.");
          // A synchronous XHR call here is generally not recommended and often blocked.
          // For example:
          // const xhr = new XMLHttpRequest();
          // xhr.open('POST', '/api/listen/end', false); // false for synchronous
          // xhr.setRequestHeader('Content-Type', 'application/json');
          // try {
          //   xhr.send(JSON.stringify({
          //     listenId: currentListenId,
          //     duration: Math.round(E.audio.duration),
          //     listenedDuration: Math.round(E.audio.currentTime)
          //   }));
          // } catch (e) { console.error("Sync XHR for beforeunload failed", e); }
        }
      }
    });

  </script>

  <script>
    // ========== ENHANCED LYRICS SCRIPT with Status Indicator & Tooltip (Self-Contained Logic) ==========

    // --- Lyrics Global Variables ---
    let idxLrcData = [];
    let idxIsSyncedLyrics = false;
    let idxLyricsSyncEnabled = true; // Default based on your HTML checkbox
    let idxGapData = [];
    let idxLastActiveLineEl = null;
    let idxCurrentLyricsSongDetails = { id: null, title: null, artist: null, toFetch: false };

    let idxLyricsStatusIndicatorEl = null; // Stores the 'Synced/Plain' text indicator element
    let idxLyricsStatusTooltipEl = null;   // Stores the tooltip element
    let idxTooltipHideTimeout = null;    // Timeout for auto-hiding tooltip

    // Thresholds for gap duration color coding
    const LYRICS_GAP_DURATION_FAST_THRESHOLD = 5;  // Gaps less than 5s are 'fast' (green)
    const LYRICS_GAP_DURATION_MEDIUM_THRESHOLD = 10; // Gaps less than 10s (and >=5s) are 'medium' (yellow)
    // Gaps >= 10s are 'big' (grey)

    function formatLRCTimestamp(totalSeconds) {
      const minutes = Math.floor(totalSeconds / 60);
      const seconds = Math.floor(totalSeconds % 60);
      const cs = Math.round((totalSeconds - Math.floor(totalSeconds)) * 100);
      return `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}.${String(cs).padStart(2, '0')}`;
    }

    // --- Tooltip Management ---
    function showLyricsStatusTooltip(targetElement, statusText) {
      if (!idxLyricsStatusTooltipEl) {
        idxLyricsStatusTooltipEl = document.createElement('div');
        idxLyricsStatusTooltipEl.id = 'lyrics-status-tooltip-popup';
        idxLyricsStatusTooltipEl.className = 'lyrics-status-tooltip';
        document.body.appendChild(idxLyricsStatusTooltipEl);
        document.addEventListener('click', (e) => {
          if (idxLyricsStatusTooltipEl && idxLyricsStatusTooltipEl.classList.contains('visible')) {
            if (!idxLyricsStatusTooltipEl.contains(e.target) && e.target !== idxLyricsStatusIndicatorEl) {
              idxLyricsStatusTooltipEl.classList.remove('visible');
            }
          }
        }, true);
      }
      clearTimeout(idxTooltipHideTimeout);
      let title = '', message = '';
      switch (statusText.toLowerCase()) {
        case 'synced': title = 'Synced Lyrics'; message = 'Lyrics scroll with music. Click line to seek.'; break;
        case 'plain': title = 'Plain Lyrics'; message = 'Standard text lyrics, no auto-scroll or seek.'; break;
        case 'loading...': title = 'Loading Lyrics'; message = 'Fetching lyrics, please wait.'; break;
        case 'error': title = 'Lyrics Error'; message = 'Could not load lyrics for this song.'; break;
        case 'n/a': title = 'Lyrics Not Available'; message = 'Lyrics are not available for this song.'; break;
        default: if (idxLyricsStatusTooltipEl) idxLyricsStatusTooltipEl.classList.remove('visible'); return;
      }
      idxLyricsStatusTooltipEl.innerHTML = `<h4>${title}</h4><p>${message}</p>`;
      const indicatorRect = targetElement.getBoundingClientRect();
      idxLyricsStatusTooltipEl.style.visibility = 'hidden';
      idxLyricsStatusTooltipEl.classList.add('visible');
      const tooltipWidth = idxLyricsStatusTooltipEl.offsetWidth;
      const tooltipHeight = idxLyricsStatusTooltipEl.offsetHeight;
      idxLyricsStatusTooltipEl.classList.remove('visible');
      idxLyricsStatusTooltipEl.style.visibility = '';
      let top = indicatorRect.bottom + window.scrollY + 8;
      let left = indicatorRect.left + window.scrollX + (indicatorRect.width / 2) - (tooltipWidth / 2);
      if (left < 10) left = 10;
      if (left + tooltipWidth > window.innerWidth - 10) left = window.innerWidth - tooltipWidth - 10;
      if ((top + tooltipHeight > window.innerHeight - 10) && (indicatorRect.top - tooltipHeight - 8 > 0)) {
        top = indicatorRect.top + window.scrollY - tooltipHeight - 8;
        idxLyricsStatusTooltipEl.classList.add('tooltip-above');
      } else {
        idxLyricsStatusTooltipEl.classList.remove('tooltip-above');
      }
      idxLyricsStatusTooltipEl.style.top = `${top}px`;
      idxLyricsStatusTooltipEl.style.left = `${left}px`;
      requestAnimationFrame(() => idxLyricsStatusTooltipEl.classList.add('visible'));
      idxTooltipHideTimeout = setTimeout(() => {
        if (idxLyricsStatusTooltipEl) idxLyricsStatusTooltipEl.classList.remove('visible');
      }, 7000);
    }

    // --- Lyrics Status Indicator Management ---
    function updateLyricsStatusIndicator(statusKey, displayText) {
      const toggleContainer = document.getElementById('lyrics-toggle-container');
      if (!toggleContainer) {
        console.warn("Lyrics toggle container not found for status indicator.");
        return;
      }
      if (!idxLyricsStatusIndicatorEl) {
        idxLyricsStatusIndicatorEl = document.createElement('span');
        idxLyricsStatusIndicatorEl.id = 'lyrics-type-indicator';
        Object.assign(idxLyricsStatusIndicatorEl.style, {
          marginLeft: '10px', padding: '3px 8px', borderRadius: '12px', fontSize: '0.75em',
          fontWeight: 'bold', verticalAlign: 'middle', color: 'white', transition: 'all 0.3s ease',
          cursor: 'pointer', boxShadow: '0 1px 3px rgba(0,0,0,0.2)', userSelect: 'none'
        });
        // Insert before the modern toggle div
        const modernToggleDiv = toggleContainer.querySelector('.modern-lyrics-toggle');
        if (modernToggleDiv) {
          toggleContainer.insertBefore(idxLyricsStatusIndicatorEl, modernToggleDiv);
        } else if (toggleContainer.firstChild) { // Fallback if modern-toggle not found yet
          toggleContainer.insertBefore(idxLyricsStatusIndicatorEl, toggleContainer.firstChild);
        }
        else {
          toggleContainer.appendChild(idxLyricsStatusIndicatorEl);
        }
        idxLyricsStatusIndicatorEl.addEventListener('click', (event) => {
          event.stopPropagation();
          showLyricsStatusTooltip(idxLyricsStatusIndicatorEl, idxLyricsStatusIndicatorEl.textContent);
        });
      }
      idxLyricsStatusIndicatorEl.textContent = displayText;
      idxLyricsStatusIndicatorEl.style.display = 'inline-block';
      let bgColor = 'rgba(150, 150, 150, 0.6)', titleAttr = 'Lyrics status - Click for details';
      switch (statusKey) {
        case 'synced': bgColor = 'rgba(29, 185, 84, 0.9)'; titleAttr = 'Synced Lyrics - Click for details'; break;
        case 'plain': bgColor = 'rgba(108, 117, 125, 0.9)'; titleAttr = 'Plain Lyrics - Click for details'; break;
        case 'loading': bgColor = 'rgba(80, 80, 150, 0.8)'; titleAttr = 'Loading lyrics...'; break;
        case 'error': bgColor = 'rgba(220, 53, 69, 0.9)'; titleAttr = 'Error loading lyrics - Click for details'; break;
      }
      idxLyricsStatusIndicatorEl.style.backgroundColor = bgColor;
      idxLyricsStatusIndicatorEl.setAttribute('title', titleAttr);
    }

    // --- Function to Setup Animation for the Lyrics Color Legend Visibility ---
    function setupLegendToggleAnimation() {
      const lyricsToggleCheckbox = document.getElementById('lyrics-toggle'); // This is the input checkbox
      const colorLegendElement = document.querySelector('.lyrics-panel-color-legend');

      if (!lyricsToggleCheckbox) {
        console.warn('Legend Animation: Lyrics toggle checkbox (id: lyrics-toggle) not found.');
        return;
      }
      if (!colorLegendElement) {
        console.warn('Legend Animation: Color legend element (class: .lyrics-panel-color-legend) not found.');
        return;
      }

      function toggleLegendVisibilityBasedOnCheckbox() {
        if (lyricsToggleCheckbox.checked) {
          colorLegendElement.classList.remove('hidden-smooth');
        } else {
          colorLegendElement.classList.add('hidden-smooth');
        }
      }

      // Set initial state
      toggleLegendVisibilityBasedOnCheckbox();

      // Event listener is added in the consolidated section below
    }


    // --- Combined Lyrics Toggle Logic ---
    const lyricsToggleCheckbox = document.getElementById('lyrics-toggle'); // The input checkbox
    const lyricsToggleSwitchLabel = document.querySelector('label.lyrics-toggle-switch-label[for="lyrics-toggle"]'); // The styled label

    if (lyricsToggleCheckbox && lyricsToggleSwitchLabel) {
      // Apply initial state for idxLyricsSyncEnabled
      idxLyricsSyncEnabled = lyricsToggleCheckbox.checked;

      const updateSwitchAndLegendState = () => {
        // Update the visual state of the custom switch (label)
        if (lyricsToggleCheckbox.checked) {
          lyricsToggleSwitchLabel.classList.add('is-checked');
        } else {
          lyricsToggleSwitchLabel.classList.remove('is-checked');
        }

        // Update the visibility of the color legend
        const colorLegendElement = document.querySelector('.lyrics-panel-color-legend');
        if (colorLegendElement) {
          if (lyricsToggleCheckbox.checked) {
            colorLegendElement.classList.remove('hidden-smooth');
          } else {
            colorLegendElement.classList.add('hidden-smooth');
          }
        }
      };

      // Set initial visual state for the switch and legend
      updateSwitchAndLegendState();

      lyricsToggleCheckbox.addEventListener('change', (e) => {
        idxLyricsSyncEnabled = e.target.checked; // Update global sync enabled flag
        if (idxLyricsStatusTooltipEl) idxLyricsStatusTooltipEl.classList.remove('visible');

        updateSwitchAndLegendState(); // Update visual state of switch and legend

        // Existing logic for lyrics highlighting
        idxUpdateLyricsHighlight();
        if (idxLyricsSyncEnabled) {
          const localLyricsLinesDiv = document.getElementById('lyrics-lines');
          if (idxIsSyncedLyrics && localLyricsLinesDiv && localLyricsLinesDiv.children.length === 0 && idxLrcData.length > 0) {
            const lrcContent = idxLrcData.map(l => `[${formatLRCTimestamp(l.time)}]${l.text}`).join('\n');
            idxDisplayLyrics({ synced: lrcContent });
          }
        }
      });

      // Accessibility: manage focus appearance on the custom switch label
      lyricsToggleCheckbox.addEventListener('focus', () => {
        lyricsToggleSwitchLabel.classList.add('js-focus-visible');
      });
      lyricsToggleCheckbox.addEventListener('blur', () => {
        lyricsToggleSwitchLabel.classList.remove('js-focus-visible');
      });

    } else {
      console.warn("Modern lyrics toggle checkbox or label not found. Switch UI might not work.");
    }


    const localLyricsLinesDivForClick = document.getElementById('lyrics-lines');
    if (localLyricsLinesDivForClick) {
      localLyricsLinesDivForClick.addEventListener('click', (event) => {
        if (idxLyricsStatusTooltipEl) idxLyricsStatusTooltipEl.classList.remove('visible');
        if (!localLyricsLinesDivForClick.contains(event.target)) return;
        if (typeof E !== 'undefined' && E.audio && idxLyricsSyncEnabled && idxIsSyncedLyrics && event.target.tagName === 'P' && event.target.dataset.time) {
          idxSeekPlayer(parseFloat(event.target.dataset.time));
        }
      });
    }

    function idxParseLRC(lrcText) {
      const lines = lrcText.split('\n'), data = [];
      const timeRegex = /\[(\d{2}):(\d{2})[.:](\d{2,3})\](.*)/;
      lines.forEach(line => {
        const match = timeRegex.exec(line);
        if (match) {
          const time = parseInt(match[1], 10) * 60 + parseInt(match[2], 10) + parseInt(match[3].length === 2 ? match[3] + '0' : match[3], 10) / 1000;
          const text = match[4].trim();
          if (text) data.push({ time, text });
        }
      });
      return data.sort((a, b) => a.time - b.time);
    }

    function idxDisplayLyrics(lyrics) {
      const localLyricsLinesDiv = document.getElementById('lyrics-lines');
      if (!localLyricsLinesDiv) { updateLyricsStatusIndicator('error', 'Error'); return; }
      localLyricsLinesDiv.innerHTML = '';
      idxLrcData = []; idxGapData = []; idxIsSyncedLyrics = false; idxLastActiveLineEl = null;
      const GAP_THRESHOLD_SECONDS = 2.9, PLACEHOLDER_TEXT_INDICATOR = "â™«";
      let lyricsContentAvailable = false;

      if (lyrics.synced) {
        idxLrcData = idxParseLRC(lyrics.synced);
        if (idxLrcData.length > 0) {
          idxIsSyncedLyrics = true; lyricsContentAvailable = true;
          const linesFragment = document.createDocumentFragment();
          for (let i = 0; i < idxLrcData.length; i++) {
            const currentLine = idxLrcData[i];
            const p = document.createElement('p');
            p.textContent = currentLine.text; p.dataset.time = currentLine.time; p.dataset.index = i;
            linesFragment.appendChild(p);
            if (i < idxLrcData.length - 1) {
              const nextLine = idxLrcData[i + 1];
              const gapDuration = nextLine.time - currentLine.time;
              if (gapDuration >= GAP_THRESHOLD_SECONDS) {
                const placeholder = document.createElement('div'); placeholder.className = 'lyrics-gap-placeholder';
                const fillBar = document.createElement('div'); fillBar.className = 'gap-fill-bar';
                fillBar.classList.remove('fast', 'medium', 'big');
                if (gapDuration < LYRICS_GAP_DURATION_FAST_THRESHOLD) fillBar.classList.add('fast');
                else if (gapDuration < LYRICS_GAP_DURATION_MEDIUM_THRESHOLD) fillBar.classList.add('medium');
                else fillBar.classList.add('big');
                placeholder.appendChild(fillBar);
                if (PLACEHOLDER_TEXT_INDICATOR) {
                  const textIndicator = document.createElement('span'); textIndicator.className = 'gap-text-indicator';
                  textIndicator.textContent = PLACEHOLDER_TEXT_INDICATOR; placeholder.appendChild(textIndicator);
                }
                linesFragment.appendChild(placeholder);
                idxGapData.push({
                  animateStartTime: currentLine.time, animateEndTime: nextLine.time, duration: gapDuration,
                  placeholderElement: placeholder, fillBarElement: fillBar
                });
              }
            }
          }
          localLyricsLinesDiv.appendChild(linesFragment);
        }
      }
      if (!idxIsSyncedLyrics && lyrics.plain && lyrics.plain.trim().length > 0) {
        lyricsContentAvailable = true;
        lyrics.plain.split('\n').forEach(lineText => {
          const p = document.createElement('p');
          p.textContent = lineText.trim() || '\u00A0'; p.classList.add('plain-lyrics');
          localLyricsLinesDiv.appendChild(p);
        });
      }
      if (lyricsContentAvailable) updateLyricsStatusIndicator(idxIsSyncedLyrics ? 'synced' : 'plain', idxIsSyncedLyrics ? 'Synced' : 'Plain');
      else {
        localLyricsLinesDiv.innerHTML = '<p class="lyrics-message">No lyrics available for this song.</p>';
        updateLyricsStatusIndicator('na', 'N/A');
      }
      idxUpdateLyricsHighlight();
    }

    async function idxFetchLyrics(songId, title, artist) {
      const localLyricsLinesDiv = document.getElementById('lyrics-lines');
      if (!localLyricsLinesDiv) return;
      updateLyricsStatusIndicator('loading', 'Loading...');
      localLyricsLinesDiv.innerHTML = '<p class="lyrics-message">Fetching lyrics...</p>';
      idxLrcData = []; idxGapData = []; idxIsSyncedLyrics = false; idxLastActiveLineEl = null;

      if (songId !== idxCurrentLyricsSongDetails.id || title !== idxCurrentLyricsSongDetails.title || artist !== idxCurrentLyricsSongDetails.artist) {
        if (idxCurrentLyricsSongDetails.toFetch) {
          updateLyricsStatusIndicator('na', 'N/A');
          if (idxLyricsStatusIndicatorEl && !(typeof E !== 'undefined' && E.fullPlayer && E.fullPlayer.classList.contains('active'))) {
            idxLyricsStatusIndicatorEl.style.display = 'none';
          }
        } return;
      }
      try {
        const response = await fetch(`/lyrics-server/lyrics?song_id=${encodeURIComponent(songId)}&title=${encodeURIComponent(title)}&artist=${encodeURIComponent(artist)}`);
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({ message: `HTTP error! status: ${response.status}` }));
          throw new Error(errorData.message || `Server error: ${response.status}`);
        }
        const data = await response.json();
        if (songId !== idxCurrentLyricsSongDetails.id || title !== idxCurrentLyricsSongDetails.title || artist !== idxCurrentLyricsSongDetails.artist) return;
        if (data.success && (data.data.synced || data.data.plain)) idxDisplayLyrics(data.data);
        else {
          localLyricsLinesDiv.innerHTML = `<p class="lyrics-message">${data.message || 'No lyrics found.'}</p>`;
          updateLyricsStatusIndicator('na', 'N/A');
        }
      } catch (error) {
        console.error('Error fetching/processing lyrics:', error);
        if (songId === idxCurrentLyricsSongDetails.id) {
          localLyricsLinesDiv.innerHTML = `<p class="lyrics-message">Could not load lyrics.</p>`;
          updateLyricsStatusIndicator('error', 'Error');
        }
      }
    }

    function idxGetCurrentPlayerTime() {
      return (typeof E !== 'undefined' && E.audio && typeof E.audio.currentTime === 'number') ? E.audio.currentTime : 0;
    }

    function idxSeekPlayer(time) {
      if (typeof E !== 'undefined' && E.audio && typeof E.audio.duration === 'number') {
        E.audio.currentTime = time;
        if (E.audio.paused) E.audio.play().catch(error => console.error("Error playing after seek:", error));
      }
    }
    // --- Custom Smooth Scroll Function ---
    function customSmoothScroll(element, to, duration) {
      const start = element.scrollTop;
      const change = to - start;
      const startTime = performance.now();

      function animateScroll() {
        const currentTime = performance.now();
        const elapsedTime = currentTime - startTime;
        const progress = Math.min(elapsedTime / duration, 1); // Ensure progress doesn't exceed 1

        // Simple linear easing for predictability at very short durations
        element.scrollTop = start + change * progress;

        if (elapsedTime < duration) {
          requestAnimationFrame(animateScroll);
        } else {
          element.scrollTop = to; // Ensure it ends exactly at the target
        }
      }
      requestAnimationFrame(animateScroll);
    }

    function idxUpdateLyricsHighlight() {
      const localLyricsContainer = document.getElementById('lyricsContainer');
      const localLyricsLinesDiv = document.getElementById('lyrics-lines');
      if (!localLyricsContainer || !localLyricsLinesDiv) return;
      const currentTime = idxGetCurrentPlayerTime();

      if (idxIsSyncedLyrics && idxLyricsSyncEnabled) {
        idxGapData.forEach(gap => {
          const isThisGapActive = (currentTime >= gap.animateStartTime && currentTime < gap.animateEndTime);
          gap.placeholderElement.classList.toggle('active', isThisGapActive);
          gap.fillBarElement.classList.remove('fast', 'medium', 'big');
          if (gap.duration < LYRICS_GAP_DURATION_FAST_THRESHOLD) gap.fillBarElement.classList.add('fast');
          else if (gap.duration < LYRICS_GAP_DURATION_MEDIUM_THRESHOLD) gap.fillBarElement.classList.add('medium');
          else gap.fillBarElement.classList.add('big');
          if (isThisGapActive) {
            gap.fillBarElement.style.width = `${Math.min(100, Math.max(0, ((currentTime - gap.animateStartTime) / gap.duration) * 100))}%`;
          } else {
            gap.fillBarElement.style.width = (currentTime >= gap.animateEndTime) ? '100%' : '0%';
          }
        });
      } else {
        idxGapData.forEach(gap => {
          gap.placeholderElement.classList.remove('active');
          gap.fillBarElement.style.width = '0%';
          gap.fillBarElement.classList.remove('fast', 'medium', 'big');
        });
      }

      if (!idxIsSyncedLyrics || !idxLyricsSyncEnabled) {
        if (idxLastActiveLineEl) idxLastActiveLineEl.classList.remove('active');
        idxLastActiveLineEl = null;
        if (localLyricsLinesDiv) {
          localLyricsLinesDiv.querySelectorAll('p.active').forEach(p => p.classList.remove('active'));
          localLyricsLinesDiv.querySelectorAll('p.past').forEach(p => p.classList.remove('past'));
        } return;
      }

      let currentLineIndex = -1, activeLineEl = null;
      for (let i = 0; i < idxLrcData.length; i++) {
        if (currentTime >= idxLrcData[i].time && currentTime < ((i + 1 < idxLrcData.length) ? idxLrcData[i + 1].time : Infinity)) {
          currentLineIndex = i; break;
        }
      }
      if (currentLineIndex === -1 && idxLrcData.length > 0 && currentTime >= idxLrcData[idxLrcData.length - 1].time) {
        currentLineIndex = idxLrcData.length - 1;
      }

      if (localLyricsLinesDiv) {
        localLyricsLinesDiv.querySelectorAll('p[data-index]').forEach(pEl => {
          const pIndex = parseInt(pEl.dataset.index, 10);
          const isActive = (pIndex === currentLineIndex);
          const isPast = (pIndex < currentLineIndex);
          pEl.classList.toggle('active', isActive); pEl.classList.toggle('past', isPast && !isActive);
          if (isActive) activeLineEl = pEl;
        });
      }

      if (activeLineEl && activeLineEl !== idxLastActiveLineEl) {
        idxLastActiveLineEl = activeLineEl;
        const lineRect = activeLineEl.getBoundingClientRect(), containerRect = localLyricsContainer.getBoundingClientRect();
        const desiredScrollTop = localLyricsContainer.scrollTop + (lineRect.top - containerRect.top) - (containerRect.height / 2) + (lineRect.height / 2);
        const scrollBuffer = containerRect.height * 0.25;
        if (lineRect.top < containerRect.top + scrollBuffer || lineRect.bottom > containerRect.bottom - scrollBuffer) {
          customSmoothScroll(localLyricsContainer, Math.max(0, desiredScrollTop), 100); // Use 100ms for a very quick scroll
        }
      } else if (currentLineIndex === -1 && idxLastActiveLineEl) {
        idxLastActiveLineEl.classList.remove('active'); idxLastActiveLineEl = null;
      }
    }

    function idxStartLyricsForSong(newSongId, newTitle, newArtist) {
      idxCurrentLyricsSongDetails = { id: newSongId, title: newTitle, artist: newArtist, toFetch: false };
      const localLyricsLinesDiv = document.getElementById('lyrics-lines');
      if (typeof E !== 'undefined' && E.fullPlayer && E.fullPlayer.classList.contains('active')) {
        if (idxLyricsStatusIndicatorEl) idxLyricsStatusIndicatorEl.style.display = 'inline-block';
        idxFetchLyrics(newSongId, newTitle, newArtist);
      } else {
        idxCurrentLyricsSongDetails.toFetch = true;
        if (localLyricsLinesDiv) localLyricsLinesDiv.innerHTML = '<p class="lyrics-message">Open full player to view lyrics.</p>';
        updateLyricsStatusIndicator('na', 'N/A');
        if (idxLyricsStatusIndicatorEl) idxLyricsStatusIndicatorEl.style.display = 'none';
      }
    }

    function idxSyncLyricsWithPlayer() {
      if (typeof E !== 'undefined' && E.fullPlayer && E.fullPlayer.classList.contains('active')) {
        idxUpdateLyricsHighlight();
      }
    }

    function onFullPlayerOpen() { // This function is called by your main player script
      if (idxLyricsStatusIndicatorEl) idxLyricsStatusIndicatorEl.style.display = 'inline-block';
      else updateLyricsStatusIndicator('loading', 'Loading...');

      const localLyricsLinesDiv = document.getElementById('lyrics-lines');
      if ((idxCurrentLyricsSongDetails.toFetch && idxCurrentLyricsSongDetails.id) ||
        (idxCurrentLyricsSongDetails.id && localLyricsLinesDiv &&
          (localLyricsLinesDiv.innerHTML.includes('lyrics-message') || localLyricsLinesDiv.children.length === 0))) {
        idxFetchLyrics(idxCurrentLyricsSongDetails.id, idxCurrentLyricsSongDetails.title, idxCurrentLyricsSongDetails.artist);
        idxCurrentLyricsSongDetails.toFetch = false;
      } else if (idxCurrentLyricsSongDetails.id) {
        if (idxIsSyncedLyrics && idxLrcData.length > 0) updateLyricsStatusIndicator('synced', 'Synced');
        else if (localLyricsLinesDiv && localLyricsLinesDiv.querySelector('p.plain-lyrics')) updateLyricsStatusIndicator('plain', 'Plain');
        else {
          const messageEl = localLyricsLinesDiv ? localLyricsLinesDiv.querySelector('.lyrics-message') : null;
          if (messageEl) {
            const msgText = messageEl.textContent.toLowerCase();
            if (msgText.includes('no lyrics available')) updateLyricsStatusIndicator('na', 'N/A');
            else if (msgText.includes('error') || msgText.includes('could not load')) updateLyricsStatusIndicator('error', 'Error');
            else if (msgText.includes('open full player')) idxFetchLyrics(idxCurrentLyricsSongDetails.id, idxCurrentLyricsSongDetails.title, idxCurrentLyricsSongDetails.artist);
            else updateLyricsStatusIndicator('loading', 'Loading...');
          } else if (localLyricsLinesDiv && localLyricsLinesDiv.children.length === 0) {
            idxFetchLyrics(idxCurrentLyricsSongDetails.id, idxCurrentLyricsSongDetails.title, idxCurrentLyricsSongDetails.artist);
          } else updateLyricsStatusIndicator('na', 'N/A');
        }
        idxUpdateLyricsHighlight();
      } else {
        updateLyricsStatusIndicator('na', 'N/A');
        if (localLyricsLinesDiv) localLyricsLinesDiv.innerHTML = '<p class="lyrics-message">No song currently loaded.</p>';
      }
      // It's a good place to ensure the legend animation setup is called if elements are ready
      // However, the most robust place is a general DOMContentLoaded or main init.
      // For this specific script, if #lyrics-toggle is guaranteed to be present when full player opens:
      // setupLegendToggleAnimation(); // - This was from previous suggestion, now integrated into the consolidated listener
    }

    const localMinimizeButton = document.getElementById('minimizeButton');
    if (localMinimizeButton) {
      localMinimizeButton.addEventListener('click', () => {
        if (idxLyricsStatusTooltipEl) idxLyricsStatusTooltipEl.classList.remove('visible');
        if (idxLyricsStatusIndicatorEl) idxLyricsStatusIndicatorEl.style.display = 'none';

        // Also hide the color legend when player is minimized
        const colorLegendElement = document.querySelector('.lyrics-panel-color-legend');
        if (colorLegendElement) {
          colorLegendElement.classList.add('hidden-smooth');
        }
      });
    }

    // Make sure setupLegendToggleAnimation is called once the relevant DOM is ready.
    // If this entire script block is at the end of your body, or called within/after DOMContentLoaded,
    // the elements should be available.
    // One way to ensure it's called after this script defines everything AND DOM is ready:
    function initLyricsPanelFeatures() {
      // The consolidated event listener for #lyrics-toggle (defined above) handles
      // both idxLyricsSyncEnabled, label class, and legend visibility.
      // So, no separate call to setupLegendToggleAnimation is needed here if the
      // consolidated listener is correctly set up.

      // If the player can be initially open, ensure legend state is correct:
      const lyricsToggleCheckboxInit = document.getElementById('lyrics-toggle');
      const colorLegendElementInit = document.querySelector('.lyrics-panel-color-legend');
      if (lyricsToggleCheckboxInit && colorLegendElementInit) {
        if (lyricsToggleCheckboxInit.checked) {
          colorLegendElementInit.classList.remove('hidden-smooth');
        } else {
          colorLegendElementInit.classList.add('hidden-smooth');
        }
      }
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initLyricsPanelFeatures);
    } else {
      initLyricsPanelFeatures(); // Or call it from your main app init
    }
  </script>


  <script>
    // ========= SANGEET PLAYER - ARTIST INFO MODULE (NEW) =========
    const SangeetPlayer_ArtistInfo = (() => {
      // Helper to get DOM elements by ID. Ensure these IDs exist in your HTML.
      const DOMElements = {
        artistImage: () => document.getElementById('artistImage'),
        artistName: () => document.getElementById('artistName'),
        artistYear: () => document.getElementById('artistYear'),
        artistGenre: () => document.getElementById('artistGenre'),
        artistDescription: () => document.getElementById('artistDescription'),
        artistSubscribers: () => document.getElementById('artistSubscribers'), // Will show '-'
        artistViews: () => document.getElementById('artistViews'),             // Will show '-'
        artistMonthlyListeners: () => document.getElementById('artistMonthlyListeners'), // Will show '-'
        topSongsList: () => document.getElementById('topSongsList'),
        artistLinks: () => document.getElementById('artistLinks'),
        artistInfoContainer: () => document.querySelector('.artist-info-container'),
        artistOverviewContainer: () => document.querySelector('.artist-overview-container')
      };

      function _showLoadingState() {
        const els = DOMElements;
        if (els.artistInfoContainer()) els.artistInfoContainer().style.display = ''; // Ensure visible
        if (els.artistOverviewContainer()) els.artistOverviewContainer().style.display = ''; // Ensure visible

        if (els.artistImage()) els.artistImage().src = '/static/images/loading.png'; // Replace with your placeholder
        if (els.artistName()) els.artistName().textContent = 'Loading Artist...';
        if (els.artistYear()) els.artistYear().textContent = 'Year: -';
        if (els.artistGenre()) els.artistGenre().textContent = 'Genre: -';
        if (els.artistDescription()) els.artistDescription().innerHTML = '<p>Loading description...</p>'; // Use innerHTML if description can be HTML
        if (els.artistSubscribers()) els.artistSubscribers().textContent = '-';
        if (els.artistViews()) els.artistViews().textContent = '-';
        if (els.artistMonthlyListeners()) els.artistMonthlyListeners().textContent = '-';
        if (els.topSongsList()) els.topSongsList().innerHTML = '<p>Loading popular songs...</p>';
        if (els.artistLinks()) els.artistLinks().innerHTML = '';
      }

      function _showErrorState(artistNameQuery, message = 'Artist information not available.') {
        const els = DOMElements;
        const primaryArtistName = artistNameQuery ? artistNameQuery.split(',')[0].split(' ft.')[0].split(' feat.')[0].split(' & ')[0].trim() : "Artist";

        if (els.artistInfoContainer()) els.artistInfoContainer().style.display = ''; // Ensure visible
        if (els.artistOverviewContainer()) els.artistOverviewContainer().style.display = ''; // Ensure visible

        if (els.artistImage()) els.artistImage().src = '/static/images/default-cover.png'; // Replace with your default
        if (els.artistName()) els.artistName().textContent = primaryArtistName;
        if (els.artistYear()) els.artistYear().textContent = 'Year: -';
        if (els.artistGenre()) els.artistGenre().textContent = 'Genre: -';
        if (els.artistDescription()) els.artistDescription().innerHTML = `<p>${message}</p>`;
        if (els.artistSubscribers()) els.artistSubscribers().textContent = '-';
        if (els.artistViews()) els.artistViews().textContent = '-';
        if (els.artistMonthlyListeners()) els.artistMonthlyListeners().textContent = '-';
        if (els.topSongsList()) els.topSongsList().innerHTML = '<p>Popular songs not available.</p>';
        if (els.artistLinks()) els.artistLinks().innerHTML = '';
      }

      function _formatSongDuration(seconds) {
        if (isNaN(seconds) || seconds < 0) return '0:00';
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = Math.floor(seconds % 60);
        return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
      }

      function _renderBasicInfo(data) {
        const els = DOMElements;
        if (els.artistImage()) els.artistImage().src = data.thumbnail || '/static/images/default-artist.png';
        if (els.artistName()) els.artistName().textContent = data.name || 'Unknown Artist';
        if (els.artistYear()) els.artistYear().textContent = data.year ? `Active Since: ${data.year}` : 'Year: Unknown';
        if (els.artistGenre()) els.artistGenre().textContent = data.genres && data.genres.length > 0 ? `Genre: ${data.genres.join(', ')}` : 'Genre: Various';
      }

      function _renderOverview(data) {
        const els = DOMElements;
        if (els.artistDescription()) {
          // The description from Python's _s_process_description might contain "..."
          // If you prefer raw HTML or Markdown rendering, adjust here.
          // For plain text with newlines:
          const descText = data.description || 'No description available for this artist.';
          els.artistDescription().innerHTML = `<p>${descText.replace(/\n/g, '<br>')}</p>`;
        }
      }

      function _renderStats(data) {
        const els = DOMElements;
        // The API's `/api/artist-info` route returns `stats: {}`.
        // The Python helper `_s_get_artist_stats` sets 'monthlyListeners': '-',
        // but this default isn't directly passed into the final `stats` object from the route.
        // Thus, all these will effectively be '-' unless the API changes to populate the `stats` object.
        if (els.artistSubscribers()) els.artistSubscribers().textContent = data.stats?.subscribers || '-';
        if (els.artistViews()) els.artistViews().textContent = data.stats?.views || '-';
        if (els.artistMonthlyListeners()) els.artistMonthlyListeners().textContent = data.stats?.monthlyListeners || '-';
      }

      function _renderTopSongs(data) {
        const els = DOMElements;
        const topSongsListContainer = els.topSongsList();
        if (!topSongsListContainer) return;

        topSongsListContainer.innerHTML = ''; // Clear previous

        if (data.topSongs && data.topSongs.length > 0) {
          const ul = document.createElement('ul');
          ul.className = 'sangeet-player-artist-top-songs-ul';
          data.topSongs.forEach((song, index) => {
            const li = document.createElement('li');
            li.className = 'top-song-item';
            li.dataset.songId = song.videoId;

            const songThumb = song.thumbnail || `https://i.ytimg.com/vi/${song.videoId}/mqdefault.jpg`;

            li.innerHTML = `
                    <img src="${songThumb}" alt="${song.title}" class="top-song-thumbnail" loading="lazy">
                    <div class="song-number">${index + 1}</div>
                    <div class="song-info">
                        <div class="song-title">${song.title}</div>
                        <div class="song-artist-name">${song.artist}</div>
                    </div>
                    <div class="song-details-right">
                        <div class="song-plays">${song.plays || '-'}</div>
                        <div class="song-duration">${_formatSongDuration(song.duration)}</div>
                    </div>
                    <button class="top-song-play-button" aria-label="Play ${song.title}">
                        <span class="material-icons">play_arrow</span>
                    </button>
                `;
            li.addEventListener('click', (e) => {
              // Prevent click on parent if play button itself is clicked
              if (e.target.closest('.top-song-play-button')) {
                e.stopPropagation();
              }
              if (typeof window.queueAndPlaySong === 'function') {
                window.queueAndPlaySong(song.videoId);
                if (typeof closeFullPlayer === 'function' && window.innerWidth < 768) { // Optional: close full player on mobile after song click
                  //  closeFullPlayer();
                }
              } else {
                console.warn('queueAndPlaySong function not found globally.');
              }
            });
            ul.appendChild(li);
          });
          topSongsListContainer.appendChild(ul);
        } else {
          topSongsListContainer.innerHTML = '<p>No popular songs found for this artist.</p>';
        }
      }

      function _renderLinks(data) {
        const els = DOMElements;
        const artistLinksContainer = els.artistLinks();
        if (!artistLinksContainer) return;

        artistLinksContainer.innerHTML = '';
        const linksPresent = [];

        if (data.links?.youtube_music) {
          const ytMusicLink = document.createElement('a');
          ytMusicLink.href = data.links.youtube_music;
          ytMusicLink.target = '_blank';
          ytMusicLink.rel = 'noopener noreferrer';
          ytMusicLink.className = 'artist-link youtube-music-link';
          ytMusicLink.innerHTML = `<span class="material-icons">music_note</span> YouTube Music`;
          artistLinksContainer.appendChild(ytMusicLink);
          linksPresent.push(ytMusicLink);
        }
        // Add other links if they become available in data.links
        // e.g., if (data.links?.official_site) { ... }

        if (linksPresent.length === 0) {
          artistLinksContainer.innerHTML = '<p>No external links available.</p>';
        }
      }

      async function loadAndDisplayArtistInfo(artistNameQuery) {
        if (!artistNameQuery || artistNameQuery.trim() === '-' || artistNameQuery.trim().toLowerCase() === 'unknown artist') {
          _showErrorState(artistNameQuery, 'Artist name not provided or is unknown.');
          const artistInfoContainer = DOMElements.artistInfoContainer();
          const artistOverviewContainer = DOMElements.artistOverviewContainer();
          if (artistInfoContainer) artistInfoContainer.style.display = 'none';
          if (artistOverviewContainer) artistOverviewContainer.style.display = 'none';
          return;
        }
        _showLoadingState();

        try {
          const response = await fetch(`/api/artist-info/${encodeURIComponent(artistNameQuery)}`);
          const data = await response.json();

          if (!response.ok || data.error) {
            console.warn(`Error fetching artist info for "${artistNameQuery}":`, data.error || response.statusText);
            _showErrorState(artistNameQuery, data.description || data.error || 'Failed to load artist information.'); // Use description from error response if available
            return;
          }

          _renderBasicInfo(data);
          _renderOverview(data);
          _renderStats(data);
          _renderTopSongs(data);
          _renderLinks(data);

        } catch (error) {
          console.error(`Exception fetching artist info for "${artistNameQuery}":`, error);
          _showErrorState(artistNameQuery, 'An error occurred while fetching artist details.');
        }
      }

      return {
        loadAndDisplayArtistInfo
      };
    })();
  </script>

  <script id="sangeet-universal-clipboard-script">
    /**
     * A universal function to copy text to the clipboard.
     * It works on both HTTPS and HTTP by using a fallback method.
     *
     * @param {string} textToCopy The text you want to copy.
     * @param {HTMLElement} [buttonElement] The button that was clicked, used for UI feedback (optional).
     * @returns {Promise<boolean>} True if copy was successful or initiated, false otherwise.
     */
    async function universalCopyToClipboard(textToCopy, buttonElement) {
      console.log(`Sangeet Universal: Attempting to copy - "${textToCopy}"`);
      const icon = buttonElement ? buttonElement.querySelector('.material-icons') : null;
      const originalIconText = icon ? icon.textContent : null;
      let toastTitle = 'Clipboard';

      // Determine context for toast messages
      if (buttonElement) {
        if (buttonElement.id.toLowerCase().includes('share') || (buttonElement.title && buttonElement.title.toLowerCase().includes('share'))) {
          toastTitle = 'Share Link';
        } else if (buttonElement.id.toLowerCase().includes('code') || (buttonElement.title && buttonElement.title.toLowerCase().includes('code'))) {
          toastTitle = 'Embed Code';
        }
      }


      const showFeedback = (isSuccess, message) => {
        if (icon && originalIconText) {
          icon.textContent = isSuccess ? 'check' : 'close';
          setTimeout(() => {
            icon.textContent = originalIconText;
          }, 2000);
        }
        const logMessage = message || (isSuccess ? 'Copied to clipboard!' : 'Failed to copy.');
        if (typeof showNotification === 'function') { // Using your NotificationManager
          showNotification(isSuccess ? 'success' : 'error', toastTitle, logMessage);
        } else if (typeof showToast === 'function') { // Fallback to generic showToast
          showToast(logMessage, isSuccess ? 'success' : 'error');
        } else {
          isSuccess ? console.log(logMessage) : console.error(logMessage);
        }
      };

      // Method 1: Modern Clipboard API (for HTTPS or secure contexts)
      if (navigator.clipboard && window.isSecureContext) {
        try {
          await navigator.clipboard.writeText(textToCopy);
          showFeedback(true, 'Copied using modern API!');
          return true;
        } catch (err) {
          console.error('Modern Clipboard API failed:', err);
          // Fall through to legacy method if modern API fails for reasons other than permission.
          if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
            showFeedback(false, 'Clipboard permission denied.');
            return false;
          }
          // For other errors, we'll try the fallback.
        }
      }

      // Method 2: Legacy Fallback (for HTTP or when modern API is unavailable/failed)
      console.log('Attempting fallback copy method for HTTP or if modern API failed.');
      const textArea = document.createElement("textarea");
      textArea.value = textToCopy;
      textArea.style.position = "fixed";
      textArea.style.top = "-9999px";
      textArea.style.left = "-9999px";
      textArea.setAttribute('readonly', ''); // Prevent keyboard popup on mobile

      document.body.appendChild(textArea);
      textArea.select();
      textArea.setSelectionRange(0, textArea.value.length); // Ensure selection for mobile

      let copied = false;
      try {
        copied = document.execCommand('copy');
        if (copied) {
          showFeedback(true, 'Copied using fallback method!');
        } else {
          // This case means execCommand itself indicated failure, not an exception.
          console.warn('document.execCommand("copy") returned false. This can happen if not triggered by a user action or if the document is not focused.');
          showFeedback(false, 'Could not copy using fallback. Try focusing the page or a different browser.');
        }
      } catch (err) {
        console.error('Legacy document.execCommand("copy") threw an error:', err);
        showFeedback(false, 'Error during fallback copy operation.');
      } finally {
        document.body.removeChild(textArea);
      }
      return copied;
    }

    // --- Attempt to Override Specific Functionalities After DOM Loads ---
    document.addEventListener('DOMContentLoaded', () => {
      console.log("Sangeet Universal Clipboard Script: DOMContentLoaded.");

      // 1. Override for the "Embed Code" copy button (#copyCode)
      // This button is inside the #integrationContainer, which is initially display: none
      // We need to ensure the listener is attached when it becomes visible or use event delegation if #integrationContainer is static.
      // For simplicity, let's assume initializeIntegration() in your script adds the #copyCode button and attaches listeners.
      // This override will replace the listener added by initializeIntegration if it's done correctly.

      // We'll target the button when the integration panel is shown.
      // A robust way is to modify your `initializeIntegration` function directly.
      // But to "override" from here:
      const integrationContainer = document.getElementById('integrationContainer');
      if (integrationContainer) {
        const observer = new MutationObserver((mutationsList, observer) => {
          for (const mutation of mutationsList) {
            if (mutation.type === 'attributes' && mutation.attributeName === 'style') {
              if (integrationContainer.style.display === 'block') {
                const copyEmbedCodeButton = document.getElementById('copyCode');
                if (copyEmbedCodeButton && !copyEmbedCodeButton.dataset.sangeetUniversalAttached) {
                  const newCopyEmbedCodeButton = copyEmbedCodeButton.cloneNode(true);
                  copyEmbedCodeButton.parentNode.replaceChild(newCopyEmbedCodeButton, copyEmbedCodeButton);

                  newCopyEmbedCodeButton.addEventListener('click', async (event) => {
                    event.preventDefault();
                    const codeElement = document.getElementById('embedCode');
                    if (codeElement) {
                      await universalCopyToClipboard(codeElement.textContent, newCopyEmbedCodeButton);
                    } else {
                      console.error('Sangeet Universal: Embed code element not found.');
                    }
                  });
                  newCopyEmbedCodeButton.dataset.sangeetUniversalAttached = 'true';
                  console.log("Sangeet Universal: Override dynamically applied for #copyCode button.");
                }
              }
            }
          }
        });
        observer.observe(integrationContainer, { attributes: true });
      } else {
        console.warn("Sangeet Universal: #integrationContainer not found for dynamic #copyCode override setup.");
      }


      // 2. Override `handleShare` function (used by mini and full player share buttons)
      // This needs to happen after the original `initializePlayerControls` has defined `window.controls`.
      // It assumes `state`, `E`, and `controls` objects are globally available as per your script.
      if (typeof window.initializePlayerControls === 'function') {
        // Attempt to redefine `handleShare` after player controls are likely initialized.
        // A slight delay might be needed if scripts load asynchronously.
        setTimeout(() => {
          if (typeof window.handleShare === 'function' || (window.controls && window.controls.share)) {
            console.log("Sangeet Universal: Attempting to redefine handleShare.");

            window.handleShare = async function () {
              console.log("Sangeet Universal: Overridden handleShare executing.");
              if (!window.state || !window.state.currentSongId) {
                if (typeof showNotification === 'function') showNotification('warning', 'Share', 'No song selected to share.');
                return;
              }

              const songId = window.state.currentSongId;
              const songTitle = window.E?.miniPlayerTitle?.textContent || 'Song';
              const songArtist = window.E?.miniPlayerArtist?.textContent || 'Artist';
              const shareUrl = `${window.location.origin}/share/open/${songId}`;
              const shareMessage = `Check out this song: ${songTitle} by ${songArtist}`;

              let buttonElement = null;
              // Check visibility more reliably
              const fullShareBtn = document.getElementById('fullShareButton');
              const miniShareBtn = document.getElementById('shareButton');

              if (fullShareBtn && fullShareBtn.offsetParent !== null) {
                buttonElement = fullShareBtn;
              } else if (miniShareBtn && miniShareBtn.offsetParent !== null) {
                buttonElement = miniShareBtn;
              }

              if (navigator.share && window.isSecureContext) {
                try {
                  await navigator.share({
                    title: `Share Song: ${songTitle}`,
                    text: shareMessage,
                    url: shareUrl
                  });
                  console.log('Sangeet Universal: Content shared via Web Share API!');
                  if (buttonElement?.querySelector('.material-icons')) {
                    const icon = buttonElement.querySelector('.material-icons');
                    const original = icon.textContent;
                    icon.textContent = 'check_circle'; // Different success icon for share
                    setTimeout(() => icon.textContent = original, 2500);
                  }
                  return;
                } catch (err) {
                  if (err.name === 'AbortError') {
                    console.log('Sangeet Universal: User cancelled Web Share.');
                    return;
                  }
                  console.warn('Sangeet Universal: Web Share API failed, falling back to clipboard.', err);
                }
              }

              // Fallback to universal clipboard copy
              await universalCopyToClipboard(shareUrl, buttonElement);
            };

            // Re-attach listeners to ensure they use the new `window.handleShare`
            // This is crucial if original listeners captured the old function reference.
            const shareButtonMini = document.getElementById('shareButton');
            if (shareButtonMini) {
              const newShareButtonMini = shareButtonMini.cloneNode(true);
              if (shareButtonMini.parentNode) shareButtonMini.parentNode.replaceChild(newShareButtonMini, shareButtonMini);
              newShareButtonMini.addEventListener('click', window.handleShare);
            }
            const shareButtonFull = document.getElementById('fullShareButton');
            if (shareButtonFull) {
              const newShareButtonFull = shareButtonFull.cloneNode(true);
              if (shareButtonFull.parentNode) shareButtonFull.parentNode.replaceChild(newShareButtonFull, shareButtonFull);
              newShareButtonFull.addEventListener('click', window.handleShare);
            }
            console.log("Sangeet Universal: Override applied for global handleShare function and listeners updated.");

          } else {
            console.warn("Sangeet Universal: Original handleShare or controls.share not found for override. Song share buttons might not use the new logic unless their original event listeners are modified to call universalCopyToClipboard.");
          }
        }, 500); // Delay to allow other scripts to initialize. Adjust if needed.
      }


      // 3. Override for PlaylistManager.sharePlaylist
      // This assumes PlaylistManager class is defined and instantiated globally or accessible.
      // This is more complex as it involves modifying a class prototype.
      if (typeof window.PlaylistManager === 'function') {
        // Check if an instance is available or if we need to wait for it.
        // For simplicity, we'll assume the prototype can be modified.
        // This should be done before any PlaylistManager instance is created if possible,
        // or instances might hold a reference to the old method.
        if (window.PlaylistManager.prototype.sharePlaylist) {
          // window.PlaylistManager.prototype.originalSharePlaylist = window.PlaylistManager.prototype.sharePlaylist; // Backup

          window.PlaylistManager.prototype.sharePlaylist = async function (playlistId) {
            console.log(`Sangeet Universal: Overridden PlaylistManager.sharePlaylist for ID: ${playlistId}`);
            // `this` refers to the PlaylistManager instance.
            // We need to find the button that triggered this if we want icon feedback.
            // This is hard without passing the event. For now, buttonElement will be null.
            let buttonElement = null; // Cannot reliably get button here.

            try {
              const response = await fetch(`/api/playlists/${playlistId}/share`, { method: 'POST' });
              if (!response.ok) throw new Error('Failed to generate share link for playlist');
              const data = await response.json();
              const shareUrl = `${window.location.origin}/playlists/share/${data.share_id}`;

              // Fetch playlist name for a better share title (optional)
              let playlistName = "This Playlist";
              try {
                // This assumes your playlist items in the modal have a way to get the name
                // or you fetch it. Example:
                const playlistModalItem = this.playlistList?.querySelector(`.playlist-item .share-playlist[data-playlist-id="${playlistId}"]`)?.closest('.playlist-item');
                if (playlistModalItem) {
                  playlistName = playlistModalItem.querySelector('.playlist-name')?.textContent || playlistName;
                  buttonElement = playlistModalItem.querySelector('.share-playlist'); // Try to get button
                }
              } catch (nameError) { console.warn("Could not get playlist name for sharing title."); }


              if (navigator.share && window.isSecureContext) {
                try {
                  await navigator.share({
                    title: `Share Playlist: ${playlistName}`,
                    text: 'Check out this playlist I made on Sangeet!',
                    url: shareUrl
                  });
                  console.log('Sangeet Universal: Playlist shared via Web Share API!');
                  if (buttonElement?.querySelector('.material-icons')) {
                    const icon = buttonElement.querySelector('.material-icons');
                    const original = icon.textContent;
                    icon.textContent = 'check_circle';
                    setTimeout(() => icon.textContent = original, 2500);
                  }
                  return;
                } catch (err) {
                  if (err.name === 'AbortError') {
                    console.log('Sangeet Universal: User cancelled Web Share for playlist.');
                    return;
                  }
                  console.warn('Sangeet Universal: Web Share API for playlist failed, falling back to clipboard.', err);
                }
              }
              await universalCopyToClipboard(shareUrl, buttonElement);
            } catch (error) {
              console.error('Sangeet Universal: Error sharing playlist via override:', error);
              if (typeof showNotification === 'function') showNotification('error', 'Playlist Share', 'Failed to share playlist.');
            }
          };
          console.log("Sangeet Universal: Override applied for PlaylistManager.prototype.sharePlaylist.");
        } else {
          console.warn("Sangeet Universal: PlaylistManager.prototype.sharePlaylist not found for override.");
        }
      } else {
        console.warn("Sangeet Universal: PlaylistManager class not found for override. Playlist share might not use new logic.");
      }

      // Log if running on HTTP for awareness of limitations
      if (window.location.protocol !== 'https:' && !['localhost', '127.0.0.1'].includes(window.location.hostname)) {
        console.warn("Sangeet Universal: Running on HTTP. Native Share API will not be available. Clipboard copy will be used as fallback.");
      }
    });
  </script>
<script>
    document.addEventListener('DOMContentLoaded', () => {
      const settingsModal = document.getElementById('settingsModal');
      const closeSettingsModal = document.getElementById('closeSettingsModal');
      const saveSettingsButton = document.getElementById('saveSettings');
      const qualityOptions = document.querySelectorAll('.quality-option');

      // NEW: Function to apply fetched settings to the UI
      const applySettingsToUI = (settings) => {
        // First, remove 'selected' from all options to reset the view
        qualityOptions.forEach(opt => opt.classList.remove('selected'));

        // Get the saved quality, or default to 'normal' if not set
        const currentQuality = settings.stream_quality || 'normal';

        // Find the option that matches the saved setting
        const selectedOption = document.querySelector(`.quality-option[data-quality="${currentQuality}"]`);
        
        if (selectedOption) {
          selectedOption.classList.add('selected');
        } else {
          // As a fallback, select 'normal' if the saved value is somehow invalid
          document.querySelector('.quality-option[data-quality="normal"]').classList.add('selected');
        }
      };

      // MODIFIED: Function to open the settings modal
      window.openSettingsModal = () => {
        settingsModal.style.display = 'flex';
        
        // NEW: Fetch current settings from the backend when the modal opens
        fetch('/fetch-settings')
          .then(response => {
            if (!response.ok) {
              // Handle auth errors or other server issues
              throw new Error('Could not fetch settings. Are you logged in?');
            }
            return response.json();
          })
          .then(data => {
            if (data.status === 'success') {
              // Apply the fetched settings to the radio buttons
              applySettingsToUI(data.settings);
            } else {
              throw new Error(data.message || 'Failed to load settings.');
            }
          })
          .catch(error => {
            console.error('Error fetching settings:', error);
            // If fetching fails, apply default settings (normal quality)
            applySettingsToUI({}); 
            showNotification('error', 'Settings Error', error.message);
          });
      };

      // Function to close the settings modal
      const closeTheSettingsModal = () => {
        settingsModal.style.display = 'none';
      };

      // Event listener for the settings icon in the hamburger menu
      const settingsTrigger = document.querySelector('[data-action="settings"]');
      if (settingsTrigger) {
          settingsTrigger.addEventListener('click', window.openSettingsModal);
      }

      // Event listener for the close button
      if (closeSettingsModal) {
          closeSettingsModal.addEventListener('click', closeTheSettingsModal);
      }
      
      // Event listeners for quality options
      qualityOptions.forEach(option => {
        option.addEventListener('click', () => {
          qualityOptions.forEach(opt => opt.classList.remove('selected'));
          option.classList.add('selected');
        });
      });

      // Event listener for the save button (This part is mostly unchanged)
      if (saveSettingsButton) {
          saveSettingsButton.addEventListener('click', () => {
            const selectedQualityElement = document.querySelector('.quality-option.selected');
            if (!selectedQualityElement) {
                showNotification('error', 'Error', 'No quality option selected.');
                return;
            }
            const selectedQuality = selectedQualityElement.dataset.quality;
    
            // Use fetch to send the chosen settings to the backend
            fetch('/settings', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                stream_quality: selectedQuality // The key matches your JSON structure
              }),
            })
              .then(response => response.json())
              .then(data => {
                if (data.status === 'success') {
                  showNotification('success', 'Success!', 'Settings saved successfully.');
                  closeTheSettingsModal();
                } else {
                  showNotification('error', 'Error', data.message || 'Failed to save settings.');
                }
              })
              .catch((error) => {
                console.error('Error:', error);
                showNotification('error', 'Error', 'An error occurred while saving settings.');
              });
          });
      }
    });
  </script>
  <script>
 // ========== START: Isolated "idx-" Portal Menu JavaScript ==========
        document.addEventListener('DOMContentLoaded', () => {
            const trigger = document.getElementById('idx-portalMenuTrigger');
            const portalMenu = document.getElementById('idx-portalMenu');
            const overlay = document.getElementById('idx-portalMenuOverlay');
            const menuContainer = document.getElementById('idx-menuContainer');
            const menuItems = document.querySelectorAll('.idx-portal-menu .idx-menu-item');
            const menuIcons = document.querySelectorAll('.idx-portal-menu .idx-menu-icon');
            const activeLabel = document.getElementById('idx-menuActiveLabel');
            const originalMenuActions = document.getElementById('idx-original-menu-actions');

            if (!trigger || !portalMenu || !menuContainer || !activeLabel || !originalMenuActions) {
                console.error("Isolated Portal Menu: One or more essential elements are missing.");
                return;
            }

            let isMenuOpen = false;
            let currentRotation = 0;
            let targetRotation = 0;
            let velocity = 0;
            const friction = 0.95;
            let isDragging = false;
            let dragMoved = false;
            let lastDragAngle = 0;
            const angleStep = 360 / menuItems.length;

            const toggleMenu = () => {
                isMenuOpen = !isMenuOpen;
                portalMenu.classList.toggle('active', isMenuOpen);
                overlay.classList.toggle('active', isMenuOpen);
                document.body.style.overflow = isMenuOpen ? 'hidden' : '';
            };

            const positionMenuItems = () => {
                const radius = menuContainer.offsetWidth / 2.2;
                menuItems.forEach((item, index) => {
                    const angle = (index * angleStep - 90) * (Math.PI / 180);
                    const x = (menuContainer.offsetWidth / 2) + radius * Math.cos(angle) - item.offsetWidth / 2;
                    const y = (menuContainer.offsetHeight / 2) + radius * Math.sin(angle) - item.offsetHeight / 2;
                    item.style.left = `${x}px`;
                    item.style.top = `${y}px`;
                });
            };

            function animate() {
                if (!isMenuOpen) {
                    velocity = 0;
                } else {
                    if (!isDragging) {
                        targetRotation += velocity;
                        velocity *= friction;
                    }
                    const rotationDiff = targetRotation - currentRotation;
                    currentRotation += rotationDiff * 0.1;
                    menuContainer.style.transform = `translate(-50%, -50%) rotate(${currentRotation}deg)`;
                    menuIcons.forEach(icon => icon.style.transform = `rotate(${-currentRotation}deg)`);
                    updateActiveItem();
                }
                requestAnimationFrame(animate);
            }

            const updateActiveItem = () => {
                const normalizedRotation = ((-currentRotation % 360) + 360) % 360;
                const activeIndex = Math.round(normalizedRotation / angleStep) % menuItems.length;
                menuItems.forEach((item, index) => {
                    const tooltip = item.querySelector('.idx-tooltip');
                    const isActive = index === activeIndex;
                    item.classList.toggle('active', isActive);
                    if (isActive && tooltip) {
                        activeLabel.textContent = tooltip.textContent;
                    }
                });
            };

            const handleItemAction = (menuItem) => {
                if (!menuItem) return;
                const action = menuItem.dataset.action;

                if (action) {
                    const originalActionItem = originalMenuActions.querySelector(`[data-action='${action}']`);
                    if (originalActionItem) {
                        console.log(`Triggering action: ${action}`);
                        originalActionItem.click();
                    } else {
                        console.warn(`Isolated Portal Menu: Could not find original action for: ${action}`);
                    }
                }

                if (menuItem.hasAttribute('onclick')) {
                    menuItem.click();
                }
                setTimeout(toggleMenu, 150);
            };

            trigger.addEventListener('click', toggleMenu);
            overlay.addEventListener('click', () => isMenuOpen && toggleMenu());
            document.addEventListener('keydown', (e) => e.key === 'Escape' && isMenuOpen && toggleMenu());

            const getAngle = (x, y) => {
                const { left, top, width, height } = portalMenu.getBoundingClientRect();
                return Math.atan2(y - (top + height / 2), x - (left + width / 2)) * (180 / Math.PI);
            };

            const startDrag = (e) => {
                if (!isMenuOpen || !e.target.closest('.idx-menu-item')) return;
                e.preventDefault();
                isDragging = true;
                dragMoved = false;
                velocity = 0;
                document.body.style.cursor = 'grabbing';
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                lastDragAngle = getAngle(clientX, clientY);
            };

            const onDrag = (e) => {
                if (!isDragging || !isMenuOpen) return;
                e.preventDefault();
                dragMoved = true;
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const currentAngle = getAngle(clientX, clientY);
                let angleDelta = currentAngle - lastDragAngle;
                if (angleDelta > 180) angleDelta -= 360;
                if (angleDelta < -180) angleDelta += 360;
                targetRotation += angleDelta;
                lastDragAngle = currentAngle;
            };

            const endDrag = (e) => {
                if (!isDragging) return;
                document.body.style.cursor = 'default';
                if (!dragMoved) {
                    handleItemAction(e.target.closest('.idx-menu-item'));
                }
                isDragging = false;
            };

            portalMenu.addEventListener('wheel', (e) => {
                if (!isMenuOpen || isDragging) return;
                e.preventDefault();
                velocity += e.deltaY > 0 ? -1.0 : 1.0;
            }, { passive: false });

            portalMenu.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', endDrag);
            portalMenu.addEventListener('touchstart', startDrag, { passive: false });
            document.addEventListener('touchmove', onDrag, { passive: false });
            document.addEventListener('touchend', endDrag);

            animate();
            setTimeout(positionMenuItems, 50);
            window.addEventListener('resize', positionMenuItems);
        });
        // ========== END: Isolated "idx-" Portal Menu JavaScript ==========
    </script>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            console.log("Connecting Portal Menu actions...");

            const actionsContainer = document.getElementById('idx-original-menu-actions');
            if (!actionsContainer) {
                console.error("Connector Script: Could not find #idx-original-menu-actions container.");
                return;
            }

            // --- Link ACTION for HISTORY ---
            const historyAction = actionsContainer.querySelector('[data-action="history"]');
            historyAction?.addEventListener('click', () => {
                // This logic is copied from your main application script
                const historyModal = document.getElementById('historyModal');
                if (historyModal && typeof loadHistory === 'function') {
                    historyModal.style.display = 'block'; // Or 'flex' depending on your CSS
                    loadHistory();
                } else {
                    alert("History modal function not ready.");
                }
            });

            // --- Link ACTION for INSIGHTS ---
            const insightsAction = actionsContainer.querySelector('[data-action="insights"]');
            insightsAction?.addEventListener('click', () => {
                // This logic is copied from your main application script
                const insightsModal = document.getElementById('insightsModal');
                if (insightsModal && typeof loadInsights === 'function') {
                    insightsModal.style.display = 'block'; // Or 'flex'
                    loadInsights();
                } else {
                    alert("Insights modal function not ready.");
                }
            });

           // --- Link ACTION for PLAYLISTS (NEW, ROBUST METHOD) ---
const playlistsAction = actionsContainer.querySelector('[data-action="playlists"]');
playlistsAction?.addEventListener('click', () => {
    // This new listener directly calls the method on the PlaylistManager instance.
    // This is the most reliable way to open the modal.
    if (window.playlistManager && typeof window.playlistManager.openPlaylistModal === 'function') {
        // The 'false' argument tells the manager to open in "view mode", not "add song mode".
        window.playlistManager.openPlaylistModal(false);
    } else {
        console.error("PlaylistManager instance not found on 'window.playlistManager'. Please ensure the main script assigns it, for example: 'window.playlistManager = new PlaylistManager();'");
        alert("Playlist feature is not available.");
    }
});

            // --- Link ACTION for SETTINGS ---
            const settingsAction = actionsContainer.querySelector('[data-action="settings"]');
            settingsAction?.addEventListener('click', () => {
                if (typeof window.openSettingsModal === 'function') {
                    window.openSettingsModal();
                } else {
                    alert("Settings modal function not ready.");
                }
            });

            // --- Link ACTION for WHAT'S NEW ---
            const whatsNewAction = actionsContainer.querySelector('[data-action="whats-new"]');
            whatsNewAction?.addEventListener('click', () => {
                if (typeof openWhatsNewModal === 'function') {
                    openWhatsNewModal();
                } else {
                    alert("What's New modal function not ready.");
                }
            });

            // --- Link ACTION for REPORT ISSUE ---
            const reportIssueAction = actionsContainer.querySelector('[data-action="report-issue"]');
            reportIssueAction?.addEventListener('click', () => {
                if (typeof window.openIssueModal === 'function') {
                    window.openIssueModal('report');
                } else {
                    alert("Issue modal function not ready.");
                }
            });
            
            console.log("Portal Menu actions connected.");
        });
  </script>

</body>

</html>